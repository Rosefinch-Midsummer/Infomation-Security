<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>信息安全</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded affix "><li class="part-title">密码学</li><li class="chapter-item expanded "><a href="密码学发展史.html"><strong aria-hidden="true">2.</strong> 密码学发展史</a></li><li class="chapter-item expanded "><a href="可读性算法.html"><strong aria-hidden="true">3.</strong> 可读性算法</a></li><li class="chapter-item expanded "><a href="对称加密算法.html"><strong aria-hidden="true">4.</strong> 对称加密算法</a></li><li class="chapter-item expanded "><a href="消息摘要算法.html"><strong aria-hidden="true">5.</strong> 消息摘要算法</a></li><li class="chapter-item expanded "><a href="非对称加密算法.html"><strong aria-hidden="true">6.</strong> 非对称加密算法</a></li><li class="chapter-item expanded "><a href="数字签名和数字证书.html"><strong aria-hidden="true">7.</strong> 数字签名和数字证书</a></li><li class="chapter-item expanded "><a href="隐写术.html"><strong aria-hidden="true">8.</strong> 隐写术</a></li><li class="chapter-item expanded affix "><li class="part-title">区块链</li><li class="chapter-item expanded affix "><li class="part-title">Solidity</li><li class="chapter-item expanded affix "><li class="part-title">Toolkit</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">信息安全</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="密码学发展史"><a class="header" href="#密码学发展史">密码学发展史</a></h1>
<ul>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6">古典密码学</a>
<ul>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E6%9B%BF%E6%8D%A2%E6%B3%95">替换法</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E7%A7%BB%E4%BD%8D%E6%B3%95">移位法</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E5%9F%BA%E4%BA%8Eascii%E7%A0%81%E7%9A%84%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81java%E5%AE%9E%E7%8E%B0">基于ASCII码的凯撒密码Java实现</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E9%99%84%E5%BD%95%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D%E5%85%B123%E4%B8%AA%E5%AD%97%E6%AF%8D">附录拉丁字母共23个字母</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%8F%8Ajava%E5%AE%9E%E7%8E%B0">古典密码破解方式及Java实现</a></li>
</ul>
</li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6">现代密码学</a>
<ul>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E6%81%A9%E5%B0%BC%E6%A0%BC%E7%8E%9B%E6%9C%BA">恩尼格玛机</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#ascii-%E7%BC%96%E7%A0%81">ASCII 编码</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81">对称密码</a></li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81">非对称密码</a></li>
</ul>
</li>
<li><a href="%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8F%B2.html#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E6%89%8D%E6%AF%94%E8%BE%83%E5%AE%89%E5%85%A8">如何设置密码才比较安全</a></li>
</ul>
<h2 id="古典密码学"><a class="header" href="#古典密码学">古典密码学</a></h2>
<p>古代就已经开始使用密码，目的：就是希望保护信息。</p>
<h3 id="替换法"><a class="header" href="#替换法">替换法</a></h3>
<p>替换法很好理解，就是用固定的信息将原文替换成无法直接阅读的密文信息。例如将 b 替换成 w ，e 替换成p ，这样<code>bee</code>单词就变换成了<code>wpp</code>，不知道替换规则的人就无法阅读出原文的含义。</p>
<p>替换法有单表替换和多表替换两种形式。单表替换即只有一张原文密文对照表单，发送者和接收者用这张表单来加密解密。在上述例子中，表单即为：<code>a b c d e - s w t r p</code> 。</p>
<p>多表替换即有多张原文密文对照表单，不同字母可以用不同表单的内容替换。</p>
<p>例如约定好表单为：表单 1：<code>abcde-swtrp</code> 、表单2：<code>abcde-chfhk</code> 、表单 3：<code>abcde-jftou</code>。</p>
<p>规定第一个字母用第三张表单，第二个字母用第一张表单，第三个字母用第二张表单，这时<code>bee</code>单词就变成了<code>(312)fpk</code> ，破解难度更高，其中 312 又叫做密钥，密钥可以事先约定好，也可以在传输过程中标记出来。</p>
<h3 id="移位法"><a class="header" href="#移位法">移位法</a></h3>
<p>移位法就是将原文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后得出密文，典型的移位法应用有 “ 恺撒密码 ”。</p>
<p>例如约定好向后移动2位（<code>abcde - cdefg</code>），这样 <code>bee</code> 单词就变换成了<code>dgg</code> 。</p>
<p>同理替换法，移位法也可以采用多表移位的方式，典型的多表案例是“维尼吉亚密码”（又译维热纳尔密码），属于多表密码的一种形式。</p>
<h3 id="基于ascii码的凯撒密码java实现"><a class="header" href="#基于ascii码的凯撒密码java实现">基于ASCII码的凯撒密码Java实现</a></h3>
<pre><code class="language-java">public class CaesarCode {
    public static void main(String[] args) {
        String orignal = "Hello world";
        // 往右边偏移三位
        int key = 3;
        // 选中我即将抽取的代码，按快捷键Ctrl + Alt + M 
        String encryptCaesar =  encryptCaesar(orignal,key);
        System.out.println("加密：" + encryptCaesar);
        String decryptCaesar =  decryptCaesar(encryptCaesar,key);
        System.out.println("解密：" + decryptCaesar);
    }
    /**
     * 使用凯撒加密方式解密数据
     *
     * @param encryptedData :密文
     * @param key           :密钥
     * @return : 源数据
     */
    public static String decryptCaesar(String encryptedData, int key) {
        // 将字符串转为字符数组
        char[] chars = encryptedData.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (char aChar : chars) {
            // 获取字符的ASCII编码
            int asciiCode = aChar;
            // 偏移数据
            asciiCode -= key;
            // 将偏移后的数据转为字符
            char result = (char) asciiCode;
            // 拼接数据
            sb.append(result);
        }
        return sb.toString();
    }
    /**
     * 使用凯撒加密方式加密数据
     *
     * @param orignal :原文
     * @param key     :密钥
     * @return :加密后的数据
     */
    public static String encryptCaesar(String orignal, int key) {
        // 将字符串转为字符数组
        char[] chars = orignal.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (char aChar : chars) {
            // 获取字符的ascii编码
            int asciiCode = aChar;
            // 偏移数据
            asciiCode += key;
            // 将偏移后的数据转为字符
            char result = (char) asciiCode;
            // 拼接数据
            sb.append(result);
        }
        return sb.toString();
    }
}

</code></pre>
<h3 id="附录拉丁字母共23个字母"><a class="header" href="#附录拉丁字母共23个字母">附录拉丁字母共23个字母</a></h3>
<p>https://www.aulafacil.com/cursos/latin/i/el-alfabeto-latino-l24462</p>
<p>El alfabeto latino lo forman las siguientes letras:</p>
<p>A B C D E F G H I J K L M N O P Q R S T V X Y Z</p>
<p>A b c d e f g h i j k l m n o p q r s t u x y z</p>
<p>El alfabeto latino tiene 23 letras.</p>
<p>Tiene una única letra para la <strong>U</strong> y la <strong>V</strong>.</p>
<blockquote>
<p>Hoy se diferencia la U de la V en la mayoría de los textos latinos, pero pueden encontrarse ediciones dónde no se diferencian estas dos letras (en este curso sí las diferenciaremos).</p>
</blockquote>
<p>Las letras <strong>K</strong>, <strong>Y</strong> y <strong>Z</strong> se utilizaban poco.</p>
<h3 id="古典密码破解方式及java实现"><a class="header" href="#古典密码破解方式及java实现">古典密码破解方式及Java实现</a></h3>
<p>古典密码虽然很简单，但是在密码史上是使用的最久的加密方式，直到“概率论”的数学方法被发现，古典密码就被破解了。</p>
<p>英文单词中字母出现的频率是不同的，e以12.702%的百分比占比最高，z 只占到0.074%，感兴趣的可以去百科查字母频率详细统计数据。如果密文数量足够大，仅仅采用频度分析法就可以破解单表的替换法或移位法。</p>
<p>多表的替换法或移位法虽然难度高一些，但如果数据量足够大的话，也是可以破解的。以维尼吉亚密码算法为例，破解方法就是先找出密文中完全相同的字母串，猜测密钥长度，得到密钥长度后再把同组的密文放在一起，使用频率分析法破解。</p>
<p>提示：直接运行下面的代码不一定会成功，这取决于文件路径设置是否正确。</p>
<p>FrequencyAnalysis.java</p>
<pre><code class="language-java">package code;

import java.io.IOException;
import java.util.*;
import java.util.Map.Entry;

/**
 * 频率分析法破解凯撒密码
 */
public class FrequencyAnalysis {
    //英文里出现次数最多的字符
    private static final char MAGIC_CHAR = 'e';
    //破解生成的最大文件数
    private static final int DE_MAX_FILE = 4;

    public static void main(String[] args) throws Exception {
        //测试1，统计字符个数
        printCharCount("article_en.txt");

        //加密文件
//		int key = 3;
//		encryptFile("src/code/article.txt", "src/code/article_en.txt", key);

        //读取加密后的文件
        String artile = Util.file2String("article_en.txt");
        //解密（会生成多个备选文件）
        decryptCaesarCode(artile, "article_de.txt");
    }

    public static void printCharCount(String path) throws IOException {
        String data = Util.file2String(path);
        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; mapList = getMaxCountChar(data);
        for (Map.Entry&lt;Character, Integer&gt; entry : mapList) {
            //输出前几位的统计信息
            System.out.println("字符'" + entry.getKey() + "'出现" + entry.getValue() + "次");
        }
    }

    public static void encryptFile(String srcFile, String destFile, int key) throws IOException {
        String artile = Util.file2String(srcFile);
        //加密文件
        String encryptData = CaesarCode.encryptCaesar(artile, key);
        //保存加密后的文件
        Util.string2File(encryptData, destFile);
    }

    /**
     * 破解凯撒密码
     * @param input 数据源
     * @return 返回解密后的数据
     */
    public static void decryptCaesarCode(String input, String destPath) {
        int deCount = 0;//当前解密生成的备选文件数
        //获取出现频率最高的字符信息（出现次数越多越靠前）
        List&lt;Entry&lt;Character, Integer&gt;&gt; mapList = getMaxCountChar(input);
        for (Entry&lt;Character, Integer&gt; entry : mapList) {
            //限制解密文件备选数
            if (deCount &gt;= DE_MAX_FILE) {
                break;
            }

            //输出前几位的统计信息
            System.out.println("字符'" + entry.getKey() + "'出现" + entry.getValue() + "次");

            ++deCount;
            //出现次数最高的字符跟MAGIC_CHAR的偏移量即为秘钥
            int key = entry.getKey() - MAGIC_CHAR;
            System.out.println("猜测key = " + key + "， 解密生成第" + deCount + "个备选文件" + "\n");
            String decrypt = CaesarCode.decryptCaesar(input, key);

            String fileName = "de_" + deCount + destPath;
            Util.string2File(decrypt, fileName);
        }
    }

    //统计String里出现最多的字符
    public static List&lt;Entry&lt;Character, Integer&gt;&gt; getMaxCountChar(String data) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
        char[] array = data.toCharArray();
        for (char c : array) {
            if(!map.containsKey(c)) {
                map.put(c, 1);
            }else{
                Integer count = map.get(c);
                map.put(c, count + 1);
            }
        }

        //输出统计信息
		/*for (Entry&lt;Character, Integer&gt; entry : map.entrySet()) {
			System.out.println(entry.getKey() + "出现" + entry.getValue() +  "次");
		}*/

        //获取获取最大值
        int maxCount = 0;
        for (Entry&lt;Character, Integer&gt; entry : map.entrySet()) {
            //不统计空格
            if (/*entry.getKey() != ' ' &amp;&amp; */entry.getValue() &gt; maxCount) {
                maxCount = entry.getValue();
            }
        }

        //map转换成list便于排序
        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; mapList = new ArrayList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet());
        //根据字符出现次数排序
        Collections.sort(mapList, new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;(){

            public int compare(Map.Entry&lt;Character, Integer&gt; o1,
                               Entry&lt;Character, Integer&gt; o2) {
                return o2.getValue().compareTo(o1.getValue());
            }
        });
        return mapList;
    }
}
</code></pre>
<p>CaesarCode.java</p>
<pre><code class="language-java">package code;

public class CaesarCode {
    public static void main(String[] args) {
        String orignal = "Hello world";
        // 往右边偏移三位
        int key = 3;
        // 选中我即将抽取的代码，按快捷键Ctrl + Alt + M
        String encryptCaesar =  encryptCaesar(orignal,key);
        System.out.println("加密：" + encryptCaesar);
        String decryptCaesar =  decryptCaesar(encryptCaesar,key);
        System.out.println("解密：" + decryptCaesar);
    }
    /**
     * 使用凯撒加密方式解密数据
     *
     * @param encryptedData :密文
     * @param key           :密钥
     * @return : 源数据
     */
    public static String decryptCaesar(String encryptedData, int key) {
        // 将字符串转为字符数组
        char[] chars = encryptedData.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (char aChar : chars) {
            // 获取字符的ASCII编码
            int asciiCode = aChar;
            // 偏移数据
            asciiCode -= key;
            // 将偏移后的数据转为字符
            char result = (char) asciiCode;
            // 拼接数据
            sb.append(result);
        }
        return sb.toString();
    }
    /**
     * 使用凯撒加密方式加密数据
     *
     * @param orignal :原文
     * @param key     :密钥
     * @return :加密后的数据
     */
    public static String encryptCaesar(String orignal, int key) {
        // 将字符串转为字符数组
        char[] chars = orignal.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (char aChar : chars) {
            // 获取字符的ascii编码
            int asciiCode = aChar;
            // 偏移数据
            asciiCode += key;
            // 将偏移后的数据转为字符
            char result = (char) asciiCode;
            // 拼接数据
            sb.append(result);
        }
        return sb.toString();
    }
}

</code></pre>
<p>Util.java</p>
<pre><code class="language-java">package code;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class Util {

    public static void print(byte[] bytes) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            sb.append(bytes[i]).append(" ");
        }
        System.out.println(sb);
    }

    public static String file2String(String path) throws IOException {
        FileReader reader = new FileReader(new File(path));
        char[] buffer = new char[1024];
        int len = -1;
        StringBuffer sb = new StringBuffer();
        while ((len = reader.read(buffer)) != -1) {
            sb.append(buffer, 0, len);
        }
        return sb.toString();
    }

    public static void string2File(String data, String path){
        FileWriter writer = null;
        try {
            writer = new FileWriter(new File(path));
            writer.write(data);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static String inputStream2String(InputStream in) throws IOException {
        int len = -1;
        byte[] buffer = new byte[1024];
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        while((len = in.read(buffer)) != -1) {
            baos.write(buffer, 0, len);
        }
        baos.close();

        return baos.toString(StandardCharsets.UTF_8);
    }
}


</code></pre>
<p>article.txt</p>
<pre><code>Chief Justice Roberts, President Carter, PresidentClinton, President Bush, President Obama, fellow Americans and people of the world, thank you.  
  
We, the citizens of America, are now joined in a great national effort to rebuild our country and restore its promise for all of our people.  
  
Together, we will determine the course of America and the world for many, many years to come. We will face challenges. We will confront hardships. But we will get the job done.  
  
Every four years we gather on these steps to carry out the orderly and peaceful transfer of power.  
  
And we are grateful to President Obama and first ladyMichelle Obama for their gracious aid throughout this transition.  
  
They have been magnificent.  
  
Thank you.  
  
Today's ceremony, however, has a very special meaning because today we are not merely transferring power from one administration toanother or from one party to another, but we are transferring power fromWashington, D.C., and giving it back to you, the people.  
  
For too long, a small group in our nation's capital has reaped the rewards of government while the people have bore the cost.Washington flourished, but the people did not share in its wealth. Politiciansprospered but the jobs left and the factories closed.  
  
The establishment protected itself, but not the citizens of our country. Their victories have not been your victories. Their triumphs havenot been your triumphs. And while they celebrated in our nation's capital,there was little to celebrate for struggling families all across our land.  
  
That all changes starting right here and right now, because this moment is your moment.  
  
It belongs to you.  
  
It belongs to everyone gathered here today and everyone watching all across America.  
  
This is your day.  
  
This is your celebration.  
  
And this, the United States of America, is your country.  
  
What truly matters is not which party controls our government, but whether our government is controlled by the people.  
  
January 20th, 2017, will be remembered as the day the people became the rulers of this nation again.  
  
The forgotten men and women of our country will be forgotten no longer. Everyone is listening to you now. You came by the tens of millionsto become part of a historic movement, the likes of which the world has neverseen before.  
  
At the center of this movement is a crucial conviction that a nation exists to serve its citizens. Americans want great schools for theirchildren, safe neighborhoods for their families and good jobs for themselves.  
  
These are just and reasonable demands of righteous people and a righteous public.  
  
But for too many of our citizens, a different reality exists.  
  
Mothers and children trapped in poverty in our inner cities,rusted out factories scattered like tombstones across the landscape of ournation.  
  
An education system flush with cash but which leaves our young and beautiful students deprived of all knowledge.  
  
And the crime and the gangs and the drugs that have stolen too many lives and robbed our country of so much unrealized potential. ThisAmerican carnage stops right here and stops right now.  
  
We are one nation, and their pain is our pain.  
  
Their dreams are our dreams, and their success will be our success. We share one heart, one home and one glorious destiny.  
  
The oath of office I take today is an oath of allegiance to all Americans.  
  
For many decades we've enriched foreign industry at the expense of American industry, subsidized the armies of other countries whileallowing for the very sad depletion of our military.  
  
We've defended other nations' borders while refusing to defend our own. And we've spent trillions and trillions of dollars overseaswhile America's infrastructure has fallen into disrepair and decay.  
  
We've made other countries rich while the wealth, strength and confidence of our country has dissipated over the horizon.  
  
One by one, the factories shuttered and left our shores with not even a thought about the millions and millions of American workers thatwere left behind.  
  
The wealth of our middle class has been ripped from their homes and then redistributed all across the world. But that is the past, andnow we are looking only to the future.  
  
We assembled here today are issuing a new decree to be heard in every city, in every foreign capital and in every hall of power. From thisday forward, a new vision will govern our land.  
  
From this day forward, it's going to be only America first,America first. Every decision on trade, on taxes, on immigration, on foreignaffairs will be made to benefit American workers and American families. We mustprotect our borders from the ravages of other countries making our product,stealing our companies and destroying our jobs.  
  
Protection will lead to great prosperity and strength. I will fight for you with every breath in my body, and I will never ever let youdown.  
  
America will start winning again, winning like never before.  
  
We will bring back our jobs.  
  
We will bring back our borders.  
  
We will bring back our wealth, and we will bring back our dreams.  
  
We will build new roads and highways and bridges and airports and tunnels and railways all across our wonderful nation.  
  
We will get our people off of welfare and back to work,rebuilding our country with American hands and American labor.  
  
We will follow two simple rules: Buy American and hireAmerican.  
  
We will seek friendship and goodwill with the nations of the world, but we do so with the understanding that it is the right of all nationsto put their own interests first.  
  
We do not seek to impose our way of life on anyone, but rather to let it shine as an example.  
  
We will shine for everyone to follow.  
  
We will re-enforce old alliances and form new ones and unite the civilized world against radical Islamic terrorism, which we will eradicatecompletely from the face of the earth.  
  
At the bedrock of our politics will be a total allegiance to the United States of America, and through our loyalty to our country we willrediscover our loyalty to each other.  
  
When you open your heart to patriotism, there is no room for prejudice.  
  
The Bible tells us how good and pleasant it is when God's people live together in unity. We must speak our minds openly, debate ourdisagreements honestly, but always pursue solidarity. When America is united,America is totally unstoppable. There should be no fear. We are protected andwe will always be protected. We will be protected by the great men and women ofour military and law enforcement. And most importantly, we will be protected byGod.  
  
Finally, we must think big and dream even bigger. InAmerica, we understand that a nation is only living as long as it is striving.We will no longer accept politicians who are all talk and no action, constantlycomplaining but never doing anything about it.  
  
The time for empty talk is over. Now arrives the hour of action.  
  
Do not allow anyone to tell you that it cannot be done. No challenge can match the heart and fight and spirit of America. We will notfail. Our country will thrive and prosper again.  
  
We stand at the birth of a new millennium, ready to unlock the mysteries of space, to free the earth from the miseries of disease, and toharness the energies, industries and technologies of tomorrow.  
  
A new national pride will stir ourselves, lift our sights and heal our divisions. It's time to remember that old wisdom our soldiers willnever forget, that whether we are black or brown or white, we all bleed thesame red blood of patriots.  
  
We all enjoy the same glorious freedoms and we all salute the same great American flag.  
  
And whether a child is born in the urban sprawl of Detroit or the windswept plains of Nebraska, they look up at the same night sky, theyfill their heart with the same dreams and they are infused with the breath oflife by the same almighty creator.  
  
So to all Americans in every city near and far, small and large, from mountain to mountain, from ocean to ocean, hear these words: Youwill never be ignored again. Your voice, your hopes and your dreams will defineour American destiny. And your courage and goodness and love will forever guideus along the way.  
  
  
Together we will make America strong again, we will makeAmerica wealthy again, we will make America proud again, we will make America safe again.  
  
And, yes, together we will make America great again.  
  
Thank you.  
  
God bless you.  
  
And God bless America.
</code></pre>
<p>破译结果：</p>
<pre><code>字符'#'出现1343次
字符'h'出现817次
字符'r'出现560次
字符'w'出现539次
字符'u'出现510次
字符'd'出现500次
...
字符'#'出现1343次
猜测key = -66， 解密生成第1个备选文件

字符'h'出现817次
猜测key = 3， 解密生成第2个备选文件

字符'r'出现560次
猜测key = 13， 解密生成第3个备选文件

字符'w'出现539次
猜测key = 18， 解密生成第4个备选文件

</code></pre>
<p>运行结果 # 出现次数最多， 我们知道在英文当中 e 出现的频率是最高的，我们假设现在 # 号，就是 e ，变形而来的 ，我们可以对照 ascii 编码表 ，我们的凯撒加密当中位移是加了一个 key ，所以我们 猜测 两个值直接相差 -66 ，我们现在就以 -66 进行解密 生成一个文件，我们查看第一个文件发现，根本读不懂，所以解密失败，我们在猜测 h 是 e ，h 和 e 之间相差3 ，所以我们在去看第二个解密文件，发现我们可以读懂，解密成功。</p>
<h2 id="现代密码学"><a class="header" href="#现代密码学">现代密码学</a></h2>
<h3 id="恩尼格玛机"><a class="header" href="#恩尼格玛机">恩尼格玛机</a></h3>
<p>核心原理：替换法，移位法</p>
<p>古典密码的安全性受到了威胁，外加使用便利性较低，到了工业化时代，近现代密码被广泛应用。</p>
<p>恩尼格玛机是二战时期纳粹德国使用的加密机器，后被英国破译，参与破译的人员有被称为计算机科学之父、人工智能之父的图灵。</p>
<p>恩尼格玛机使用的加密方式本质上还是移位和替代，只不过因为密码表种类极多，破解难度高，同时加密解密机器化，使用便捷，因而在二战时期得以使用。</p>
<h3 id="ascii-编码"><a class="header" href="#ascii-编码">ASCII 编码</a></h3>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。</p>
<p>字符串转换成ascii码 Java实现</p>
<pre><code class="language-java">public class AsciiDemo {
    public static void main(String[] args) {
//        char a = 'A';
//        int b = a;
//        System.out.println(b);
        String a = "AaZ";
        // 获取ascii码，需要把字符串转成字符  65 97 90
        char[] chars = a.toCharArray();
        for (char c : chars) {
            int asciiCode = c;
            System.out.print(asciiCode);
        }
    }
}

</code></pre>
<h3 id="散列函数"><a class="header" href="#散列函数">散列函数</a></h3>
<p>散列函数，也见杂凑函数、摘要函数或哈希函数，可将任意长度的消息经过运算，变成固定长度数值，常见的有MD5、SHA-1、SHA256、SHA512，多应用在文件校验，数字签名中。</p>
<p>MD5 可以将任意长度的原文生成一个128位（16字节）的哈希值</p>
<p>SHA-1可以将任意长度的原文生成一个160位（20字节）的哈希值</p>
<h3 id="对称密码"><a class="header" href="#对称密码">对称密码</a></h3>
<p>常见的对称密码加密方式是DES、AES。</p>
<p>对称密码应用了相同的加密密钥和解密密钥。对称密码分为：序列密码(流密码)，分组密码(块密码)两种。流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，块密码是先对信息流分块，再对每一块分别加密。</p>
<p>例如原文为1234567890，流加密即先对1进行加密，再对2进行加密，再对3进行加密……最后拼接成密文；块加密先分成不同的块，如1234成块，5678成块，90XX(XX为补位数字)成块，再分别对不同块进行加密，最后拼接成密文。前文提到的古典密码学加密方法，都属于流加密。</p>
<h3 id="非对称密码"><a class="header" href="#非对称密码">非对称密码</a></h3>
<p>对称密码的密钥安全极其重要，加密者和解密者需要提前协商密钥，并各自确保密钥的安全性，一但密钥泄露，即使算法是安全的也无法保障原文信息的私密性。</p>
<p>在实际的使用中，远程的提前协商密钥不容易实现，即使协商好，在远程传输过程中也容易被他人获取，因此非对称密钥此时就凸显出了优势。</p>
<p>非对称密码有两支密钥，公钥（public key）和私钥（private key），加密和解密运算使用的密钥不同。用公钥对原文进行加密后，需要由私钥进行解密；用私钥对原文进行加密后（此时一般称为签名），需要由公钥进行解密（此时一般称为验签）。公钥可以公开的，大家使用公钥对信息进行加密，再发送给私钥的持有者，私钥持有者使用私钥对信息进行解密，获得信息原文。因为私钥只有单一人持有，因此不用担心被他人解密获取信息原文。</p>
<h2 id="如何设置密码才比较安全"><a class="header" href="#如何设置密码才比较安全">如何设置密码才比较安全</a></h2>
<ul>
<li>密码不要太常见，不要使用类似于123456式的常用密码。</li>
<li>各应用软件密码建议不同，避免出现一个应用数据库被脱库，全部应用密码崩塌，</li>
<li>可在设置密码时增加注册时间、注册地点、应用特性等方法。例如tianjin123456，表示在天津注册的该应用。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="可读性算法"><a class="header" href="#可读性算法">可读性算法</a></h1>
<ul>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#base64">Base64</a>
<ul>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#python-%E8%B0%83%E7%94%A8">Python 调用</a></li>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#java-%E8%B0%83%E7%94%A8">Java 调用</a></li>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#java%E4%B8%ADtostring%E5%92%8Cnew-string%E5%8C%BA%E5%88%AB">Java中toString()和new String()区别</a></li>
</ul>
</li>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#base58">Base58</a>
<ul>
<li><a href="%E5%8F%AF%E8%AF%BB%E6%80%A7%E7%AE%97%E6%B3%95.html#python%E5%AE%9E%E7%8E%B0">Python实现</a></li>
</ul>
</li>
</ul>
<h2 id="base64"><a class="header" href="#base64">Base64</a></h2>
<p>Base64算法是一种用于将二进制数据转换为文本数据的编码方式。它由美国程序员Joe Simons在1973年创立，最初是用来将二进制数据以ASCII编码的形式传输到网络上。Base64 不是加密算法，是可读性算法，目的是提升数据的可读性。</p>
<p>Base64算法的原理是将三个字节的输入数据按照一定的规则划分成四个6位的片段，然后将每个6位的片段转换为对应的Base64字符。最后再在末尾加上1-2个“=”符号，以保证编码后的数据长度为4的倍数。Base64算法的编码表是由大小写字母、数字和“+”、“/”符号组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img/20240911185148.png" alt="" /></p>
<h3 id="python-调用"><a class="header" href="#python-调用">Python 调用</a></h3>
<p>在Python中，可以使用base64模块来实现Base64算法的编码和解码。下面是一个示例代码：</p>
<pre><code class="language-python">import base64

# 将字符串编码为Base64
text = "Hello, World!"
encoded_text = base64.b64encode(text.encode('utf-8'))
print(encoded_text)

# 将Base64编码的字符串解码
decoded_text = base64.b64decode(encoded_text).decode('utf-8')
print(decoded_text)
</code></pre>
<p>以上代码中，首先将字符串“Hello, World!”编码为Base64格式的数据，然后再将其解码为原始字符串。通过使用base64模块，我们可以方便地在Python中进行Base64编码和解码的操作。</p>
<h3 id="java-调用"><a class="header" href="#java-调用">Java 调用</a></h3>
<p>要使用Base64编码和解码，在Java中可以使用java.util.Base64类。可以通过以下方法来导入Base64类：</p>
<pre><code class="language-java">import java.util.Base64;
</code></pre>
<p>然后使用Base64编码和解码的例子如下：</p>
<pre><code class="language-java">public class Base64Example {

    public static void main(String[] args) {
        String originalString = "Hello, World!";
        
        // 编码
        String encodedString = Base64.getEncoder().encodeToString(originalString.getBytes());
        System.out.println("Encoded string: " + encodedString);
        
        // 解码
        byte[] decodedBytes = Base64.getDecoder().decode(encodedString);
        String decodedString = new String(decodedBytes);
        System.out.println("Decoded string: " + decodedString);
    }
}
</code></pre>
<p>以上代码首先将原始字符串"Hello, World!"进行编码，然后再进行解码。最终输出结果如下：</p>
<pre><code>Encoded string: SGVsbG8sIFdvcmxkIQ==
Decoded string: Hello, World!
</code></pre>
<p>这样就实现了用Base64和Java对字符串进行加密和解密。</p>
<h3 id="java中tostring和new-string区别"><a class="header" href="#java中tostring和new-string区别">Java中toString()和new String()区别</a></h3>
<pre><code class="language-java">package code;

import java.util.Base64;

public class TestBase64 {
    public static void main(String[] args) {

        String str = "TU0jV0xBTiNVYys5bEdiUjZlNU45aHJ0bTdDQStBPT0jNjQ2NDY1Njk4IzM5OTkwMDAwMzAwMA==";

        String rlt1 = new String(Base64.getDecoder().decode(str));//MM#WLAN#Uc+9lGbR6e5N9hrtm7CA+A==#646465698#399900003000

        String rlt2 = Base64.getDecoder().decode(str).toString();//[B@1540e19d

        System.out.println(rlt1);
        System.out.println(rlt2);
    }
}
</code></pre>
<p>str.toString是调用了这个object对象的类的toString方法。一般是返回这么一个String：<code>[class name]@[hashCode]</code></p>
<p>new String(str)是根据parameter是一个字节数组，使用java虚拟机默认的编码格式，将这个字节数组decode为对应的字符。若虚拟机默认的编码格式是ISO-8859-1，按照ascii编码表即可得到字节对应的字符。</p>
<p>什么时候用什么方法呢？</p>
<p>一般使用字符转码byte[]数组的时候使用new String()</p>
<p>对象打印的时候使用toString()</p>
<h2 id="base58"><a class="header" href="#base58">Base58</a></h2>
<p>Base58算法是一种类似于Base64算法的编码方式，它也用于将二进制数据转换为文本数据。与Base64不同的是，Base58算法不包含容易产生混淆的字符，比如0(数字零)、O(大写字母O)、I(大写字母I)、l(小写字母L)，也不包含"+"和"/"符号。</p>
<p>Base58算法通常用于生成易于阅读和书写的短链接、Bitcoin地址等。</p>
<p>Base58算法没有明确的作者和起源，但最为人熟知的是由比特币的创始人中本聪设计并应用于比特币地址的生成。</p>
<p>Base58算法的原理和Base64类似，将输入数据按照一定的规则划分成固定长度的片段，然后对每个片段进行编码转换为Base58字符。Base58算法的编码表通常是由除了易混淆字符外的58个字符组成。</p>
<h3 id="python实现"><a class="header" href="#python实现">Python实现</a></h3>
<p>在Python中，我们可以使用base58模块来实现Base58算法的编码和解码。以下是一个简单示例代码：</p>
<pre><code class="language-python">from base58 import b58encode, b58decode

# 将字符串编码为Base58
text = "Hello, World!"
encoded_text = b58encode(text.encode('utf-8'))
print(encoded_text)

# 将Base58编码的字符串解码
decoded_text = b58decode(encoded_text).decode('utf-8')
print(decoded_text)
</code></pre>
<p>通过使用base58模块，我们可以轻松地在Python中实现Base58算法的编码和解码操作。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="对称加密算法"><a class="header" href="#对称加密算法">对称加密算法</a></h1>
<ul>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#des">DES</a>
<ul>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#java%E8%B0%83%E7%94%A8desecbpkcs5padding">Java调用（DES/ECB/PKCS5Padding）</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#python%E8%B0%83%E7%94%A8">Python调用</a></li>
</ul>
</li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#aes">AES</a>
<ul>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%8E%9F%E7%90%86-1">原理</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#java%E5%AE%9E%E7%8E%B0aesecbpkcs5padding">Java实现（AES/ECB/PKCS5Padding）</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#python%E5%AE%9E%E7%8E%B0">Python实现</a></li>
</ul>
</li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F">加密方式</a>
<ul>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#ecbelectronic-codebook">ECB(Electronic codebook)</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#cbccipher-block-chaining">CBC(Cipher-block chaining)</a></li>
</ul>
</li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F">填充模式</a>
<ul>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#nopadding">NoPadding</a></li>
<li><a href="%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#pkcs5padding">PKCS5Padding</a></li>
</ul>
</li>
</ul>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>默认情况下加密模式和填充模式为ECB/PKCS5Padding</p>
<p>使用CBC加密方式，加密、解密都需要创建IV向量。IV向量的长度也必须是特定长度的整数倍。</p>
<p>特点</p>
<ul>
<li>加密速度快, 可以加密大文件</li>
<li>密文可逆, 一旦密钥文件泄漏, 就会导致数据暴露</li>
<li>加密后编码表找不到对应字符, 出现乱码</li>
<li>一般结合Base64使用，解决乱码的问题</li>
</ul>
<h2 id="des"><a class="header" href="#des">DES</a></h2>
<p>DES : Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。</p>
<p>密钥key必须是8位</p>
<h3 id="原理"><a class="header" href="#原理">原理</a></h3>
<p>DES（Data Encryption Standard）是一种对称加密算法，其原理基于置换和替代。下面是DES加密算法的工作原理：</p>
<ol>
<li>
<p><strong>密钥生成</strong>：DES算法使用固定长度的密钥（56位）进行加密和解密。首先，根据用户提供的密钥，生成16个子密钥，每个子密钥48位长。</p>
</li>
<li>
<p><strong>初始置换（Initial Permutation）</strong>：明文经过一个固定的初始置换IP（Initial Permutation）置换后得到一个64位的数据块。</p>
</li>
<li>
<p><strong>轮函数（Round Function）</strong>：DES算法使用16轮替换-置换网络（Feistel Network）来加密数据。每一轮中，明文的左半部分和右半部分会分别经过一系列的替代和置换操作，并且会使用不同的子密钥。</p>
</li>
<li>
<p><strong>替代操作（Substitution）</strong>：在DES算法中，会使用S盒进行替代操作。S盒是一个4x16的矩阵，将6位输入映射为4位输出。DES算法共有8个不同的S盒。</p>
</li>
<li>
<p><strong>置换操作（Permutation）</strong>：DES算法中还会进行置换操作，将数据重新排列以增加其随机性。</p>
</li>
<li>
<p><strong>逆初始置换（Final Permutation）</strong>：经过16轮的替换和置换操作后，得到的加密结果会经过逆初始置换IP^-1，将64位数据块重新排列并输出。</p>
</li>
<li>
<p><strong>密文输出</strong>：经过逆初始置换后得到的密文即为加密结果。</p>
</li>
</ol>
<p>总的来说，DES算法通过多轮的替换和置换操作来加密数据，并且通过密钥生成子密钥来增加加密的随机性。虽然DES算法曾经是比较安全的加密算法，但由于密钥长度较短，目前已经不适合用于加密敏感数据，因此已经被更高级的加密算法如AES所取代。</p>
<h3 id="java调用desecbpkcs5padding"><a class="header" href="#java调用desecbpkcs5padding">Java调用（DES/ECB/PKCS5Padding）</a></h3>
<pre><code class="language-java">package code;

import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class DESDemo {
    // DES加密算法,key的大小必须是8个字节

    public static void main(String[] args) throws Exception {
        String input = "硅谷";
        // DES加密算法，比较高级，所以key的大小必须是8个字节
        String key = "12345678";

        String transformation = "DES/ECB/PKCS5Padding"; // 加密算法/加密模式/填充方式
        // 指定获取密钥的算法
        String algorithm = "DES";
        // 先测试加密，然后在测试解密
        String encryptDES = encryptDES(input, key, transformation, algorithm);
        System.out.println("加密:" + encryptDES);
        String s = decryptDES(encryptDES, key, transformation, algorithm);
        System.out.println("解密:" + s);

    }

    /**
     * 使用DES加密数据
     *
     * @param input          : 原文
     * @param key            : 密钥(DES, 密钥的长度必须是16个字节)
     * @param transformation : 获取Cipher对象的算法
     * @param algorithm      : 获取密钥的算法
     * @return : 密文
     * @throws Exception
     */
    private static String encryptDES(String input, String key, String transformation, String algorithm) throws Exception {
        // 获取加密对象
        Cipher cipher = Cipher.getInstance(transformation);
        // 创建加密规则
        SecretKeySpec sks = new SecretKeySpec(key.getBytes(), algorithm);
        // ENCRYPT_MODE：加密模式
        // DECRYPT_MODE: 解密模式
        // 初始化加密模式和算法
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        // 加密
        byte[] bytes = cipher.doFinal(input.getBytes());

        // 输出加密后的数据

        return Base64.getEncoder().encodeToString(bytes);
    }

    /**
     * 使用DES解密
     *
     * @param input          : 密文
     * @param key            : 密钥
     * @param transformation : 获取Cipher对象的算法
     * @param algorithm      : 获取密钥的算法
     * @return: 原文
     * @throws Exception
     */
    private static String decryptDES(String input, String key, String transformation, String algorithm) throws Exception {
        // 获取Cipher对象
        Cipher cipher = Cipher.getInstance(transformation);
        // 指定密钥规则
        SecretKeySpec sks = new SecretKeySpec(key.getBytes(), algorithm);
        cipher.init(Cipher.DECRYPT_MODE, sks);
        // 解密
        byte[] bytes = cipher.doFinal(Base64.getDecoder().decode(input));

        return new String(bytes);
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>加密:qANksk5lvqM=
解密:硅谷
</code></pre>
<h3 id="python调用"><a class="header" href="#python调用">Python调用</a></h3>
<p>在Python中使用DES加密可以使用<code>pycryptodome</code>库。以下是一个用DES算法加密字符串“打倒老大哥”并进行解密的示例代码：</p>
<pre><code class="language-python">from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
import base64

def encrypt_text(text):
    key = b'abcdefgh'  # DES密钥必须是8个字节
    cipher = DES.new(key, DES.MODE_ECB)
    padded_data = text.ljust(8 * (len(text) // 8 + 1), ' ')  # 补齐数据长度为8的倍数
    ciphertext = cipher.encrypt(padded_data.encode('utf-8'))
    encrypted_text = base64.b64encode(ciphertext).decode('utf-8')
    return encrypted_text

def decrypt_text(encrypted_text):
    key = b'abcdefgh'  # DES密钥必须是8个字节
    cipher = DES.new(key, DES.MODE_ECB)
    ciphertext = base64.b64decode(encrypted_text.encode('utf-8'))
    decrypted_data = cipher.decrypt(ciphertext).decode('utf-8').strip()
    return decrypted_data

text = "打倒老大哥"
encrypted_text = encrypt_text(text)
print("加密后的字符串:", encrypted_text)

decrypted_text = decrypt_text(encrypted_text)
print("解密后的字符串:", decrypted_text)
</code></pre>
<p>在这个示例代码中，我们使用了DES算法，并指定了ECB模式。首先定义了DES加密的密钥<code>key</code>，并创建一个DES加密对象<code>cipher</code>。然后对要加密的明文补齐至8的倍数长度，使用密钥对明文进行加密，再将加密后的密文进行Base64编码以便于输出。</p>
<p>运行以上代码，将会先输出加密后的密文，然后再输出解密后的原始明文，即可完成先加密后解密的过程。请注意，在实际应用中，需要注意密文传输的安全性和确保密钥只有合法的用户能够访问。</p>
<h2 id="aes"><a class="header" href="#aes">AES</a></h2>
<p>AES : Advanced Encryption Standard, 高级加密标准 .在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p>
<p>密钥key必须是16位</p>
<h3 id="原理-1"><a class="header" href="#原理-1">原理</a></h3>
<p>AES（Advanced Encryption Standard）是一种对称加密算法，其原理基于替代和置换。下面是AES加密算法的工作原理：</p>
<ol>
<li>
<p><strong>密钥扩展（Key Expansion）</strong>：AES算法使用固定长度的密钥（128位、192位或256位）来进行加密和解密。在加密和解密过程中，需要生成轮密钥（Round Key）。轮密钥是从初始密钥生成的一系列密钥，每一轮加密或解密过程都使用不同的轮密钥。密钥扩展算法根据初始密钥生成足够的轮密钥。</p>
</li>
<li>
<p><strong>初始轮（Initial Round）</strong>：AES算法首先使用初始轮密钥对明文进行初始处理。初始轮包括字节替换（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。</p>
</li>
<li>
<p><strong>多轮加密（Rounds）</strong>：AES算法使用多轮加密来保障数据安全。每一轮加密包括字节替换、行移位、列混淆和轮密钥加这四个步骤。加密轮数取决于密钥长度，128位密钥需要10轮，192位密钥需要12轮，256位密钥需要14轮。</p>
</li>
<li>
<p><strong>最终轮（Final Round）</strong>：在最后一轮加密中，不执行列混淆步骤。最后一轮只包括字节替换、行移位和轮密钥加这三个步骤。</p>
</li>
<li>
<p><strong>密文输出（Cipher Text）</strong>：经过多轮加密后，明文被转换成密文。最后输出的密文即为加密结果。</p>
</li>
</ol>
<p>总的来说，AES算法是通过多轮的替代和置换操作来保证数据的安全性。密钥长度的不同会导致加密的轮数、轮密钥数量的不同，从而增加了加密的强度和安全性。AES算法是目前最为常用和安全的加密算法之一。</p>
<h3 id="java实现aesecbpkcs5padding"><a class="header" href="#java实现aesecbpkcs5padding">Java实现（AES/ECB/PKCS5Padding）</a></h3>
<pre><code class="language-java">package code;

import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AESDemo {

    public static void main(String[] args) throws Exception {
        String input = "硅谷";
        // AES加密算法，比较高级，所以key的大小必须是16个字节
        String key = "1234567812345678";

        String transformation = "AES/ECB/PKCS5Padding"; // 加密算法/加密模式/填充方式
        // 指定获取密钥的算法
        String algorithm = "AES";
        // 先测试加密，然后在测试解密
        String encryptAES = encryptAES(input, key, transformation, algorithm);
        System.out.println("加密:" + encryptAES);
        String s = decryptAES(encryptAES, key, transformation, algorithm);
        System.out.println("解密:" + s);

    }

    /**
     * 使用AES加密数据
     *
     * @param input          : 原文
     * @param key            : 密钥(AES, 密钥的长度必须是16个字节)
     * @param transformation : 获取Cipher对象的算法
     * @param algorithm      : 获取密钥的算法
     * @return : 密文
     * @throws Exception
     */
    private static String encryptAES(String input, String key, String transformation, String algorithm) throws Exception {
        // 获取加密对象
        Cipher cipher = Cipher.getInstance(transformation);
        // 创建加密规则
        SecretKeySpec sks = new SecretKeySpec(key.getBytes(), algorithm);
        // ENCRYPT_MODE：加密模式
        // DECRYPT_MODE: 解密模式
        // 初始化加密模式和算法
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        // 加密
        byte[] bytes = cipher.doFinal(input.getBytes());

        // 输出加密后的数据  

        return Base64.getEncoder().encodeToString(bytes);
    }

    /**
     * 使用AES解密
     *
     * @param input          : 密文
     * @param key            : 密钥
     * @param transformation : 获取Cipher对象的算法
     * @param algorithm      : 获取密钥的算法
     * @return: 原文
     * @throws Exception
     */
    private static String decryptAES(String input, String key, String transformation, String algorithm) throws Exception {
        // 获取Cipher对象
        Cipher cipher = Cipher.getInstance(transformation);
        // 指定密钥规则
        SecretKeySpec sks = new SecretKeySpec(key.getBytes(), algorithm);
        cipher.init(Cipher.DECRYPT_MODE, sks);
        // 解密
        byte[] bytes = cipher.doFinal(Base64.getDecoder().decode(input));

        return new String(bytes);
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>加密:LIdHYmgk7CfTDY/pvc/SlQ==
解密:硅谷
</code></pre>
<h3 id="python实现-1"><a class="header" href="#python实现-1">Python实现</a></h3>
<p>在Python中使用AES加密可以通过<code>pycryptodome</code>库来实现。</p>
<p>要先对字符串进行加密，然后再对加密后的密文进行解密，可以修改上面的代码稍作调整。下面是一个完整的示例代码：</p>
<pre><code class="language-python">from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import base64

def encrypt_text(text):
    key = b'Sixteen byte key'  # AES密钥必须是16个字节（128位）
    cipher = AES.new(key, AES.MODE_ECB)
    padded_data = text.ljust(16 * (len(text) // 16 + 1), ' ')  # 补齐数据长度为16的倍数
    ciphertext = cipher.encrypt(padded_data.encode('utf-8'))
    encrypted_text = base64.b64encode(ciphertext).decode('utf-8')
    return encrypted_text

def decrypt_text(encrypted_text):
    key = b'Sixteen byte key'  # AES密钥必须是16个字节（128位）
    cipher = AES.new(key, AES.MODE_ECB)
    ciphertext = base64.b64decode(encrypted_text.encode('utf-8'))
    decrypted_data = cipher.decrypt(ciphertext).decode('utf-8').strip()
    return decrypted_data

text = "打倒老大哥"
encrypted_text = encrypt_text(text)
print("加密后的字符串:", encrypted_text)

decrypted_text = decrypt_text(encrypted_text)
print("解密后的字符串:", decrypted_text)
</code></pre>
<p>在这个示例代码中，我们添加了一个<code>decrypt_text</code>函数来实现对加密后的密文进行解密。在解密函数中，我们同样需要提供AES加密时使用的密钥，并使用相同的AES对象对密文进行解密操作，最后得到原始的明文。</p>
<p>运行以上代码，将会先输出加密后的密文，然后再输出解密后的原始明文，即可完成先加密后解密的过程。请注意，在实际应用中，需要注意密文传输的安全性和确保密钥只有合法的用户能够访问。</p>
<h2 id="加密方式"><a class="header" href="#加密方式">加密方式</a></h2>
<p>前面DES和AES都有key，而加密模式是说怎么用key。</p>
<p>ECB是同key并行，CBC是变key串行</p>
<p>对称加密中的加密模式有很多种，其中比较常见的有 ECB（Electronic Codebook）、CBC（Cipher Block Chaining）、CFB（Cipher Feedback）、OFB（Output Feedback）、CTR（Counter）等。</p>
<ol>
<li>ECB（Electronic Codebook）模式：</li>
</ol>
<p>ECB 是最简单的加密模式，将明文分成固定大小的块，然后每个块独立加密。虽然简单易实现，但由于每个块独立加密，导致相同明文块会得到相同的密文块，存在明显的安全问题。</p>
<ol start="2">
<li>CBC（Cipher Block Chaining）模式：</li>
</ol>
<p>CBC 是一种常见的加密模式，是将前一个加密块的密文和当前明文块进行异或操作，再进行加密。每个块的加密依赖于前一个块的密文，避免了 ECB 模式的问题，并提高了安全性。</p>
<ol start="3">
<li>CFB（Cipher Feedback）模式：</li>
</ol>
<p>CFB 模式将密文作为输入反馈到密码算法中生成密文块，再与明文块异或生成最终的密文。CFB 模式可以将块密码转换为流密码使用，适合于需要实时传输的数据加密。</p>
<ol start="4">
<li>OFB（Output Feedback）模式：</li>
</ol>
<p>OFB 模式将前一个加密块输出作为输入反馈到密码算法中生成密钥流，再与明文异或得到密文。OFB 模式不依赖于前一个块的密文，因此可以提高并行加密的速度。</p>
<ol start="5">
<li>CTR（Counter）模式：</li>
</ol>
<p>CTR 模式通过一个计数器和一个初始化向量生成密钥流，再与明文异或得到密文。CTR 模式避免了与前一个块的依赖关系，并可以实现高效的并行加密。</p>
<p>这些是常见的对称加密模式，每种模式都有自己的特点和适用场景，选择合适的加密模式可以提高数据的安全性和性能。</p>
<h3 id="ecbelectronic-codebook"><a class="header" href="#ecbelectronic-codebook">ECB(Electronic codebook)</a></h3>
<p>电子密码本按照密码块的大小把需要加密的消息分为数个块，然后使用同一个key对每个块分别加密。</p>
<p>优点：可以并行处理数据</p>
<p>缺点：同样的原文生成同样的密文，不能很好地保护数据</p>
<p>同时加密，原文一样则密文也一样。</p>
<h3 id="cbccipher-block-chaining"><a class="header" href="#cbccipher-block-chaining">CBC(Cipher-block chaining)</a></h3>
<p>密码块链接，每个明文块都与前一个密文块进行异或运算后，再使用同一个key进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。</p>
<p>优点：同样的原文生成的密文不一样</p>
<p>缺点：串行处理数据，速度较慢</p>
<h2 id="填充模式"><a class="header" href="#填充模式">填充模式</a></h2>
<p>对称加密中的填充模式是为了解决明文长度不满足加密算法块大小要求时的处理方式。常见的填充模式有 PKCS#5/PKCS#7 填充、ISO7816-4 填充、Zero 填充和ANSI X.923 填充等。</p>
<ol>
<li>PKCS#5/PKCS#7 填充：</li>
</ol>
<p>PKCS#5 和 PKCS#7 填充是较为常见的填充模式，它们在加密前将明文填充到加密块的大小，填充内容是填充的字节数。PKCS#5 不允许填充长度为块大小，而 PKCS#7 需要填充块大小的长度。在解密时，根据最后一个字节的填充长度可以准确去除填充。</p>
<ol start="2">
<li>ISO7816-4 填充：</li>
</ol>
<p>ISO7816-4 填充是一种简单的填充模式，将剩余需要填充的字节数用 0x80 填充，剩余的位置用 0x00 填充。在解密时，找到第一个 0x80 并移除，后面的 0x00 即为填充部分。</p>
<ol start="3">
<li>Zero 填充：</li>
</ol>
<p>Zero 填充是一种填充模式，将剩余需要填充的字节数用 0x00 填充。在解密时就需要遍历找到非 0 字节，判断是否是填充部分并去除。</p>
<ol start="4">
<li>ANSI X.923 填充：</li>
</ol>
<p>ANSI X.923 填充是一种填充模式，将剩余需要填充的字节数用 0x00 填充，最后一个字节记录填充的长度。在解密时，根据最后一个字节的填充长度可以准确去除填充。</p>
<p>以上是常见的对称加密中的填充模式，选择合适的填充模式可以保证数据在加密后正确性和完整性，并避免数据截断的问题。不同的填充模式适用于不同的场景和系统要求，需要根据具体需求选择合适的填充模式。</p>
<h3 id="nopadding"><a class="header" href="#nopadding">NoPadding</a></h3>
<p>不填充。</p>
<p>使用DES加密算法时，要求原文长度必须是8byte的整数倍</p>
<p>使用AES加密算法时，要求原文长度必须是16byte的整数倍</p>
<h3 id="pkcs5padding"><a class="header" href="#pkcs5padding">PKCS5Padding</a></h3>
<p>数据块大小为8位，不够就补足。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="消息摘要散列函数"><a class="header" href="#消息摘要散列函数">消息摘要（散列函数）</a></h1>
<ul>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">常用算法</a>
<ul>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#md5">MD5</a></li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#sha%E7%B3%BB%E5%88%97">SHA系列</a></li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#crc%E7%B3%BB%E5%88%97">CRC系列</a></li>
</ul>
</li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E5%BA%94%E7%94%A8java%E5%AE%9E%E7%8E%B0">消息摘要应用（Java实现）</a>
<ul>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81">获取字符串消息摘要</a></li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95">其他数字摘要算法</a></li>
<li><a href="%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81">获取文件消息摘要</a></li>
</ul>
</li>
</ul>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p>消息摘要（Message Digest）又称为数字摘要(Digital Digest)。</p>
<p>消息摘要是密码学中一种用于对消息或数据进行摘要和验证的技术。在消息摘要算法中，输入一段数据，经过算法处理后得到一个固定长度的摘要（通常为固定位数的字符串），此摘要就是对原始数据的一种"指纹"，不同的数据将会产生不同的摘要。消息摘要的主要作用是确保数据的完整性和验证数据的真实性，防止数据在传输过程中被篡改。</p>
<p>只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。</p>
<p>消息摘要是单向、不可逆的。</p>
<h2 id="常用算法"><a class="header" href="#常用算法">常用算法</a></h2>
<p>常用的消息摘要算法包括MD5（Message Digest Algorithm 5）、SHA系列（Secure Hash Algorithm，包括SHA-1、SHA-256、SHA-512等）、CRC系列（Cyclic Redundancy Check，包括CRC-32）等。其中，MD5是一种多用途的消息摘要算法，SHA-1是较为安全的消息摘要算法，SHA-256和SHA-512具有更高的安全性。</p>
<p>MD5算法 : 摘要结果16个字节, 转16进制后32个字节</p>
<p>SHA1算法 : 摘要结果20个字节, 转16进制后40个字节</p>
<p>SHA256算法 : 摘要结果32个字节, 转16进制后64个字节</p>
<p>SHA512算法 : 摘要结果64个字节, 转16进制后128个字节</p>
<p>消息摘要算法在网络通信、数字签名、数据校验等领域广泛应用，能够有效地验证数据的完整性和真实性，保障信息安全。通过比对接收到的消息摘要和计算得到的消息摘要，可以确认数据的完整性和可靠性，防止恶意篡改而导致数据的不一致性。因此，消息摘要在信息安全领域中具有重要的意义。</p>
<h3 id="md5"><a class="header" href="#md5">MD5</a></h3>
<p>MD5（Message Digest Algorithm 5）是一种广泛使用的消息摘要算法，用于产生数据的哈希值。MD5算法的原理是将输入的任意长度的数据经过一系列复杂的运算转换成一个128位的二进制数字，然后再将这个128位的二进制数字转换成32位的16进制数字，得到最终的MD5摘要。</p>
<p>Python中可以使用 hashlib 模块来调用MD5算法进行摘要计算。以下是一个简单的Python代码示例，将文本”Heil hiter“使用MD5算法进行加密：</p>
<pre><code class="language-python">import hashlib

# 要加密的文本
text = "Heil hiter"

# 创建一个MD5对象
md5 = hashlib.md5()

# 更新MD5对象的摘要数据
md5.update(text.encode('utf-8'))

# 获取摘要结果
result = md5.hexdigest()

print("MD5加密结果为:", result)
</code></pre>
<p>以上代码首先导入 hashlib 模块，然后定义了要加密的文本为"Hello, World!"，创建了一个 MD5 对象，更新了文本数据并计算了摘要结果，最后打印出了MD5加密结果。</p>
<p>需要注意的是，MD5算法由于存在已知的安全漏洞，不再被推荐用于安全性要求较高的场景，建议使用更安全的哈希算法如SHA-256等。</p>
<h3 id="sha系列"><a class="header" href="#sha系列">SHA系列</a></h3>
<p>SHA算法系列（Secure Hash Algorithm）包括了多个版本，比如SHA-1、SHA-256、SHA-512等，它们都是用于产生数据的哈希值的安全哈希函数。这些算法的原理是将输入的数据进行一系列复杂的转换和运算，最终生成一个固定长度的哈希值。</p>
<ol>
<li>
<p>SHA-1：SHA-1算法产生一个160位的哈希值，通常被认为比MD5更安全。不过，由于存在碰撞攻击等问题，SHA-1算法现在也逐渐被废弃。</p>
</li>
<li>
<p>SHA-256：SHA-256算法生成一个256位的哈希值，安全性更高，常用于安全领域。</p>
</li>
<li>
<p>SHA-512：SHA-512算法生成一个512位的哈希值，比SHA-256更安全，适用于对安全性要求更高的场景。</p>
</li>
</ol>
<p>下面是一个使用Python调用SHA-1、SHA-256和SHA-512算法进行加密的示例：</p>
<pre><code class="language-python">import hashlib

# 要加密的文本
text = "Heil hiter"

# 使用SHA-1算法加密
sha1 = hashlib.sha1()
sha1.update(text.encode('utf-8'))
sha1_result = sha1.hexdigest()
print("SHA-1加密结果为:", sha1_result)

# 使用SHA-256算法加密
sha256 = hashlib.sha256()
sha256.update(text.encode('utf-8'))
sha256_result = sha256.hexdigest()
print("SHA-256加密结果为:", sha256_result)

# 使用SHA-512算法加密
sha512 = hashlib.sha512()
sha512.update(text.encode('utf-8'))
sha512_result = sha512.hexdigest()
print("SHA-512加密结果为:", sha512_result)
</code></pre>
<p>以上代码将输入文本"Heil hiter"使用SHA-1、SHA-256和SHA-512算法进行加密，分别得到对应的加密结果并打印出来。这样就可以通过Python调用这些哈希算法来对数据进行加密了。</p>
<h3 id="crc系列"><a class="header" href="#crc系列">CRC系列</a></h3>
<p>CRC（Cyclic Redundancy Check）是一种循环冗余校验算法，用于检测数据在传输中是否发生错误或被篡改。CRC算法使用的是多项式除法的方法，通过对数据进行位操作和异或运算生成校验值。</p>
<p>常见的CRC算法包括CRC-32、CRC-16等，其中CRC-32是较为常用的一种，通常用于数据传输校验。</p>
<p>下面是一个使用Python调用CRC-32算法进行校验的示例：</p>
<pre><code class="language-python">import binascii

# 要加密的文本
text = "Heil hiter"

# 计算CRC-32校验值
crc32 = binascii.crc32(text.encode('utf-8')) &amp; 0xffffffff
print("CRC-32校验结果为:", hex(crc32))
</code></pre>
<p>以上代码首先导入了 binascii 模块，然后将文本"Heil hiter"转换为UTF-8编码后，使用 crc32 方法计算CRC-32校验值，最后输出校验结果。需要注意的时，在计算CRC-32校验值时，需要将结果进行位运算与 0xffffffff，以确保结果为一个32位无符号整数。</p>
<p>通过以上示例代码，可以实现对数据进行CRC校验，并得到相应的校验值。CRC算法在数据传输校验、网络通信等领域有着广泛的应用，通过校验值可以快速检测数据在传输中是否发生错误或被篡改。</p>
<h2 id="消息摘要应用java实现"><a class="header" href="#消息摘要应用java实现">消息摘要应用（Java实现）</a></h2>
<h3 id="获取字符串消息摘要"><a class="header" href="#获取字符串消息摘要">获取字符串消息摘要</a></h3>
<pre><code class="language-java">package com.atguigu.digest;

import javax.sound.midi.Soundbank;
import java.security.MessageDigest;

public class DigestDemo1 {

    public static void main(String[] args) throws Exception{
        // 原文
        String input = "aa";
        // 算法
        String algorithm = "MD5";
        // 获取数字摘要对象
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        // 获取消息数字摘要的字节数组
        byte[] digest = messageDigest.digest(input.getBytes());//原文
        System.out.println(new String(digest));
    }
}

</code></pre>
<p>运行：乱码，所以我们可以使用Base64转一下</p>
<p>1.9.3 base64 编码</p>
<pre><code class="language-java">package com.atguigu.digest;

import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.sound.midi.Soundbank;
import java.security.MessageDigest;

public class DigestDemo1 {

    public static void main(String[] args) throws Exception{
        // 原文
        String input = "aa";
        // 算法
        String algorithm = "MD5";
        // 获取数字摘要对象
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        // 消息数字摘要
        byte[] digest = messageDigest.digest(input.getBytes());
//        System.out.println(new String(digest));
        // base64编码
        System.out.println(Base64.encode(digest));
    }
}

</code></pre>
<p>运行：QSS8CpM1wn8IbyS6IHpJEg==</p>
<p>使用在线 md5 加密 ，发现我们生成的值和代码生成的值不一样，那是因为消息摘要不是使用base64进行编码的，所以我们需要把值转成16进制</p>
<p>数字摘要转换成 16 进制：虽然我们不能显示负数，但是我们可以显示字符串，把原来的字节码不用ASCII表示，改用16进制表示即可</p>
<pre><code>// 4124bc0a9335c27f086f24ba207a4912     md5 在线校验
// QSS8CpM1wn8IbyS6IHpJEg==             消息摘要使用的是16进制
</code></pre>
<p>代码转成16进制</p>
<p>要注意的是，要有补0的操作，原因在于Integer.toHexString(b &amp; 0xff);这个语句，如果字节是00001111的话，只得到了F</p>
<pre><code class="language-java">package com.atguigu.digest;

import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.sound.midi.Soundbank;
import java.security.MessageDigest;

public class DigestDemo1 {

    public static void main(String[] args) throws Exception{
        // 4124bc0a9335c27f086f24ba207a4912     md5 在线校验
        // QSS8CpM1wn8IbyS6IHpJEg==             消息摘要使用的是16进制
        // 原文
        String input = "aa";
        // 算法
        String algorithm = "MD5";
        // 获取数字摘要对象
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        // 消息数字摘要
        byte[] digest = messageDigest.digest(input.getBytes());
//        System.out.println(new String(digest));
        // base64编码
//        System.out.println(Base64.encode(digest));
        // 创建对象用来拼接
        StringBuilder sb = new StringBuilder();

        for (byte b : digest) {
            // 转成 16进制
            String s = Integer.toHexString(b &amp; 0xff);
            //System.out.println(s);
            if (s.length() == 1){
                // 如果生成的字符只有一个，前面补0
                s = "0"+s;
            }
            sb.append(s);
        }
        System.out.println(sb.toString());
        
    }
}

</code></pre>
<p>运行：4124bc0a9335c27f086f24ba207a4912</p>
<h3 id="其他数字摘要算法"><a class="header" href="#其他数字摘要算法">其他数字摘要算法</a></h3>
<pre><code class="language-java">package com.atguigu.digest;

import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.sound.midi.Soundbank;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class DigestDemo1 {

    public static void main(String[] args) throws Exception{
        // 4124bc0a9335c27f086f24ba207a4912     md5 在线校验
        // QSS8CpM1wn8IbyS6IHpJEg==             消息摘要使用的是16进制
        // 原文
        String input = "aa";
        // 算法
        String algorithm = "MD5";
        // 获取数字摘要对象
        String md5 = getDigest(input, "MD5");
        System.out.println(md5);

        String sha1 = getDigest(input, "SHA-1");
        System.out.println(sha1);

        String sha256 = getDigest(input, "SHA-256");
        System.out.println(sha256);

        String sha512 = getDigest(input, "SHA-512");
        System.out.println(sha512);


    }

    private static String toHex(byte[] digest) throws Exception {

//        System.out.println(new String(digest));
        // base64编码
//        System.out.println(Base64.encode(digest));
        // 创建对象用来拼接
        StringBuilder sb = new StringBuilder();

        for (byte b : digest) {
            // 转成 16进制
            String s = Integer.toHexString(b &amp; 0xff);
            if (s.length() == 1){
                // 如果生成的字符只有一个，前面补0
                s = "0"+s;
            }
            sb.append(s);
        }
        System.out.println("16进制数据的长度：" + sb.toString().getBytes().length);
        return sb.toString();
    }

    private static String getDigest(String input, String algorithm) throws Exception {
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        // 消息数字摘要
        byte[] digest = messageDigest.digest(input.getBytes());
        System.out.println("密文的字节长度:" + digest.length);

        return toHex(digest);
    }
}

</code></pre>
<h3 id="获取文件消息摘要"><a class="header" href="#获取文件消息摘要">获取文件消息摘要</a></h3>
<pre><code class="language-java">package com.atguigu.digest;

import com.sun.org.apache.xml.internal.security.utils.Base64;
import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
import sun.misc.BASE64Decoder;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.security.MessageDigest;

public class DigestDemo {

    public static void main(String[] args) throws Exception{
        String input = "aa";
        String algorithm = "MD5";

        // sha1 可以实现秒传功能

        String sha1 = getDigestFile("apache-tomcat-9.0.10-windows-x64.zip", "SHA-1");
        System.out.println(sha1);

        String sha512 = getDigestFile("apache-tomcat-9.0.10-windows-x64.zip", "SHA-512");
        System.out.println(sha512);

        String md5 = getDigest("aa", "MD5");
        System.out.println(md5);

        String md51 = getDigest("aa ", "MD5");
        System.out.println(md51);
    }

    private static String getDigestFile(String filePath, String algorithm) throws Exception{
        FileInputStream fis = new FileInputStream(filePath);
        int len;
        byte[] buffer = new byte[1024];
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        while ( (len =  fis.read(buffer))!=-1){
            baos.write(buffer,0,len);
        }
        // 获取消息摘要对象
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        // 获取消息摘要
        byte[] digest = messageDigest.digest(baos.toByteArray());
        System.out.println("密文的字节长度："+digest.length);
        return toHex(digest);
    }

    private static String getDigest(String input, String algorithm) throws Exception{
        MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
        byte[] digest = messageDigest.digest(input.getBytes());
        System.out.println("密文的字节长度："+digest.length);
        return toHex(digest);
    }

    private static String toHex(byte[] digest) {
        //        System.out.println(new String(digest));
        // 消息摘要进行表示的时候，是用16进制进行表示
        StringBuilder sb = new StringBuilder();
        for (byte b : digest) {
            // 转成16进制

            String s = Integer.toHexString(b &amp; 0xff);
            // 保持数据的完整性，前面不够的用0补齐
            if (s.length()==1){
                s="0"+s;
            }
            sb.append(s);
        }
        System.out.println("16进制数据的长度:"+ sb.toString().getBytes().length);
        return sb.toString();
    }
}

</code></pre>
<p>运行程序 ，获取 sha-1 和 sha-512 的值</p>
<p>使用 sha-1 算法，可以实现秒传功能，不管咱们如何修改文件的名字，最后得到的值是一样的</p>
<p>如果原文修改了，那么sha-1值 就会不一样</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="非对称加密算法"><a class="header" href="#非对称加密算法">非对称加密算法</a></h1>
<ul>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95rsa">常见算法——RSA</a>
<ul>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E6%95%B0%E5%AD%97%E7%A4%BA%E4%BE%8B">数字示例</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#python%E5%AE%9E%E6%88%98rsa">Python实战RSA</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#javascript%E5%AE%9E%E6%88%98rsa">JavaScript实战RSA</a></li>
</ul>
</li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95ecc">常见算法——ECC</a>
<ul>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E5%8E%9F%E7%90%86-1">原理</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#python%E5%AE%9E%E6%88%98ecc">Python实战ECC</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#javascript%E5%AE%9E%E6%88%98ecc">JavaScript实战ECC</a></li>
</ul>
</li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#java-rsa%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%AE%8C%E6%95%B4%E5%AE%9E%E8%B7%B5">Java-RSA加解密完整实践</a>
<ul>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5">生成公钥和私钥</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86">私钥加密</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86">私钥加密私钥解密</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86%E5%85%AC%E9%92%A5%E8%A7%A3%E5%AF%86">私钥加密公钥解密</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E4%BF%9D%E5%AD%98%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5">保存公钥和私钥</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E8%AF%BB%E5%8F%96%E7%A7%81%E9%92%A5">读取私钥</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#%E8%AF%BB%E5%8F%96%E5%85%AC%E9%92%A5">读取公钥</a></li>
<li><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html#rsa%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">RSA加解密完整代码</a></li>
</ul>
</li>
</ul>
<h2 id="简介-2"><a class="header" href="#简介-2">简介</a></h2>
<p>① 非对称加密算法又称现代加密算法。</p>
<p>② 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。</p>
<p>③ 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（public key） 和私有密钥（private key）</p>
<p>④ 公开密钥和私有密钥是一对</p>
<p>⑤ 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。</p>
<p>⑥ 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p>
<p>⑦ 因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<h2 id="特点"><a class="header" href="#特点">特点</a></h2>
<ul>
<li>加密和解密使用不同的密钥</li>
<li>如果使用私钥加密, 只能使用公钥解密</li>
<li>如果使用公钥加密, 只能使用私钥解密</li>
<li>处理数据的速度较慢, 因为安全级别高</li>
</ul>
<h2 id="常见算法rsa"><a class="header" href="#常见算法rsa">常见算法——RSA</a></h2>
<p>RSA算法是一种非对称加密算法，由罗纳德·李维斯特和阿迪·萨莫尔等人发明的。RSA算法的原理基于数论中的大数分解问题，即将一个大数分解为其质因数的乘积。因为大数分解是一个非常困难的问题，使得RSA算法能够提供较高的安全性。</p>
<p>RSA算法的原理是基于两个密钥，分别为公钥和私钥。公钥用于加密数据，私钥用于解密数据。首先，生成一对公钥和私钥，并将公钥发布给他人，而私钥保密。当他人想要向你发送加密的数据时，他们使用你的公钥对数据进行加密，只有持有私钥的你才能解密数据。</p>
<p>RSA算法广泛应用在安全传输和加密通信领域，如HTTPS通信、数字签名、加密文档等。其安全性和可靠性使得RSA成为公认的重要加密算法之一。</p>
<h3 id="原理-2"><a class="header" href="#原理-2">原理</a></h3>
<p>假设Alice想要向Bob发送加密的消息，他们采用RSA算法进行加密和解密。</p>
<ol>
<li>
<p>生成公钥和私钥：
Alice生成公钥(n, e)和私钥(n, d)。其中，n是两个大素数p和q的乘积，e是与(d * e mod φ(n) = 1)互质的数，d是e的模φ(n)的乘法逆元。</p>
</li>
<li>
<p>加密消息：
Alice获取Bob的公钥(n, e)，并将消息M转换为整数m。然后，使用公钥进行加密，计算密文c = m^e mod n。</p>
</li>
<li>
<p>解密消息：
Bob收到密文c后，使用自己的私钥进行解密，计算明文消息m = c^d mod n。</p>
</li>
</ol>
<p>这样，Bob就成功解密了Alice发送的消息。RSA算法通过公钥和私钥的配对来保证数据的安全传输和机密性。</p>
<h3 id="数字示例"><a class="header" href="#数字示例">数字示例</a></h3>
<p>首先生成密钥对, 公钥为(5,14), 私钥为(11,14)</p>
<p>现在A希望将原文2发送给B</p>
<p>A使用公钥加密数据， 2的5次方mod 14 = 4 , 将密文4发送给B</p>
<p>B使用私钥解密数据， 4的11次方mod14 = 2, 得到原文2</p>
<h3 id="python实战rsa"><a class="header" href="#python实战rsa">Python实战RSA</a></h3>
<p>以下是一个使用Python实现RSA算法的示例，并对给定明文进行加密和解密：</p>
<p>RSA算法示例：</p>
<pre><code class="language-python">from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

# 生成RSA密钥对
key = RSA.generate(2048)
public_key = key.publickey()
private_key = key

# 加密和解密操作
cipher = PKCS1_v1_5.new(public_key)
text = "新中国还在黎明中等待复苏"
encrypted = cipher.encrypt(text.encode('utf-8'))

decrypt_cipher = PKCS1_v1_5.new(private_key)
decrypted = decrypt_cipher.decrypt(encrypted, None).decode('utf-8')

print("RSA加密后的密文：", encrypted)
print("RSA解密后的明文：", decrypted)
</code></pre>
<p>这两个示例演示了如何使用Python中的RSA和ECC算法对给定的明文进行加密和解密操作。请注意，为了运行这些示例，您可能需要安装相应的密码学库（如pycryptodome和cryptography）。</p>
<h3 id="javascript实战rsa"><a class="header" href="#javascript实战rsa">JavaScript实战RSA</a></h3>
<p>以下是一个使用JavaScript调用RSA算法的示例：</p>
<p>RSA算法示例：</p>
<pre><code class="language-javascript">// 使用CryptoJS库进行RSA加密
const publicKey = "&lt;公钥&gt;";  // 公钥需要替换为实际的公钥
const plainText = "新中国还在黎明中等待复苏";
const encrypted = CryptoJS.AES.encrypt(plainText, publicKey).toString();

console.log("RSA加密后的密文：", encrypted);
</code></pre>
<p>以上示例中使用了CryptoJS库进行RSA加密，具体的实现细节需要您根据实际情况调整。</p>
<h2 id="常见算法ecc"><a class="header" href="#常见算法ecc">常见算法——ECC</a></h2>
<p>椭圆曲线密码学（ECC）是一种基于椭圆曲线理论的密码学技术。ECC的起源可追溯到1985年，由Neal Koblitz和Victor Miller提出。ECC算法在比传统RSA算法更短的密钥长度下，提供了相同甚至更高的安全性，因此在资源受限的环境中广泛应用。</p>
<p>ECC算法的原理是基于椭圆曲线上的点运算。椭圆曲线是由满足特定方程的点构成的集合，具有一些特殊的数学性质。对于给定的椭圆曲线、基点和一条直线，通过多次点运算，可以实现椭圆曲线上的加法、减法、倍乘等操作。ECC算法使用这些点运算来实现加密和签名操作。</p>
<p>ECC算法的应用包括加密通信、数字签名、身份认证等领域。在移动设备、IoT设备和智能卡等资源受限的环境中，ECC算法可以提供更高效的安全解决方案。随着量子计算机等新兴技术的发展，ECC算法也被认为是一种抵御量子计算攻击的有效手段。因此，ECC算法在密码学领域具有重要的地位和广泛的应用前景。</p>
<h3 id="原理-3"><a class="header" href="#原理-3">原理</a></h3>
<p>假设Alice和Bob想要使用ECC算法进行加密和解密通信。</p>
<ol>
<li>
<p>生成公钥和私钥：
Alice和Bob各自生成一对公钥和私钥。每对密钥包括一个椭圆曲线上的点作为公钥，以及一个私钥作为椭圆曲线上的一个整数。</p>
</li>
<li>
<p>加密消息：
Alice先将消息m转换为椭圆曲线上的点P，然后使用Bob的公钥点Q对P进行倍乘运算，得到密文点C = k * Q。将C发送给Bob。</p>
</li>
<li>
<p>解密消息：
Bob收到密文点C后，使用自己的私钥整数k对C进行倍乘运算，计算得到解密后的点P = k * C。然后将P转换为明文消息m。</p>
</li>
</ol>
<p>这样，Bob成功解密了Alice发送的消息。ECC算法通过椭圆曲线上的点运算来保证数据的安全传输和机密性。</p>
<h3 id="python实战ecc"><a class="header" href="#python实战ecc">Python实战ECC</a></h3>
<p>以下是一个使用Python实现ECC算法的示例，并对给定明文进行加密和解密：</p>
<p>ECC算法示例：</p>
<pre><code class="language-python">from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends import default_backend

# 生成ECC密钥对
private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
public_key = private_key.public_key()

# 加密和解密操作
encrypted = public_key.encrypt(b"新中国还在黎明中等待复苏", ec.ECIES())
decrypted = private_key.decrypt(encrypted, ec.ECIES())

print("ECC加密后的密文：", encrypted)
print("ECC解密后的明文：", decrypted.decode('utf-8'))
</code></pre>
<p>这两个示例演示了如何使用Python中的RSA和ECC算法对给定的明文进行加密和解密操作。请注意，为了运行这些示例，您可能需要安装相应的密码学库（如pycryptodome和cryptography）。</p>
<h3 id="javascript实战ecc"><a class="header" href="#javascript实战ecc">JavaScript实战ECC</a></h3>
<p>以下是一个使用JavaScript调用ECC算法的示例：</p>
<p>ECC算法示例：</p>
<pre><code class="language-javascript">// 使用elliptic库进行ECC加密
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');  // 选择椭圆曲线参数
const key = ec.genKeyPair();

const plainText = "新中国还在黎明中等待复苏";
const message = Buffer.from(plainText, 'utf8');

const signature = key.sign(message);
const validSignature = key.verify(message, signature);

console.log("ECC签名：", signature);
console.log("ECC签名验证结果：", validSignature);
</code></pre>
<p>以上示例中使用了elliptic库进行ECC签名和验证操作，具体的实现细节需要您根据实际情况调整。请注意，为了运行这些示例，您可能需要安装相应的JavaScript密码学库。</p>
<h2 id="java-rsa加解密完整实践"><a class="header" href="#java-rsa加解密完整实践">Java-RSA加解密完整实践</a></h2>
<h3 id="生成公钥和私钥"><a class="header" href="#生成公钥和私钥">生成公钥和私钥</a></h3>
<p>生成RSA的公钥私钥：KeyPairGenerator类</p>
<pre><code class="language-java">package code.async;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        // 加密算法
        String algorithm = "RSA";
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);
        // 打印私钥
        System.out.println(privateKeyString);
        // 打印公钥
        System.out.println(publicKeyString);
    }
}

</code></pre>
<p>运行程序：先打印的是私钥 ， 后面打印的是公钥</p>
<h3 id="私钥加密"><a class="header" href="#私钥加密">私钥加密</a></h3>
<pre><code class="language-java">package code.async;

import javax.crypto.Cipher;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String plainText = "硅谷没有包子，就像中南海没有小李子一样。没有鸡翅，你吃的什么？";

        // 加密算法
        String algorithm = "RSA";
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);

        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE,privateKey);
        // 私钥加密
        byte[] bytes = cipher.doFinal(plainText.getBytes());
        System.out.println(Base64.getEncoder().encodeToString(bytes));
    }
}

</code></pre>
<h3 id="私钥加密私钥解密"><a class="header" href="#私钥加密私钥解密">私钥加密私钥解密</a></h3>
<pre><code class="language-java">package code.async;

import javax.crypto.Cipher;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String plainText = "硅谷没有包子，就像中南海没有小李子一样。没有鸡翅，你吃的什么？";

        // 加密算法
        String algorithm = "RSA";
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);

        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE,privateKey);
        // 私钥加密
        byte[] bytes = cipher.doFinal(plainText.getBytes());
        System.out.println(Base64.getEncoder().encodeToString(bytes));

        // 私钥进行解密
        cipher.init(Cipher.DECRYPT_MODE,privateKey);
        // 对密文进行解密，不需要使用base64，因为原文不会乱码
        byte[] bytes1 = cipher.doFinal(bytes);
        System.out.println(new String(bytes1));
    }
}


</code></pre>
<p>运行程序 ，报错。</p>
<p>原因：私钥加密，只能公钥解密</p>
<h3 id="私钥加密公钥解密"><a class="header" href="#私钥加密公钥解密">私钥加密公钥解密</a></h3>
<pre><code class="language-java">package code.async;

import javax.crypto.Cipher;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String plainText = "硅谷没有包子，就像中南海没有小李子一样。没有鸡翅，你吃的什么？";

        // 加密算法
        String algorithm = "RSA";
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);

        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE,privateKey);
        // 私钥加密
        byte[] bytes = cipher.doFinal(plainText.getBytes());
        System.out.println(Base64.getEncoder().encodeToString(bytes));

        // 私钥进行解密
        cipher.init(Cipher.DECRYPT_MODE,publicKey);
        // 对密文进行解密，不需要使用base64，因为原文不会乱码
        byte[] bytes1 = cipher.doFinal(bytes);
        System.out.println(new String(bytes1));
    }
}

</code></pre>
<p>成功输出明文。</p>
<h3 id="保存公钥和私钥"><a class="header" href="#保存公钥和私钥">保存公钥和私钥</a></h3>
<pre><code class="language-java">package com.TianHan;

import javax.crypto.Cipher;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.util.Base64;
import org.apache.commons.io.FileUtils;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        // 加密算法
        String algorithm = "RSA";

        //生成密钥对并保存在本地文件中
        generateKeyToFile(algorithm, "./code/src/main/resources/a.pub", "./code/src/main/resources/a.pri");
    }

    /**
     * 生成密钥对并保存在本地文件中
     *
     * @param algorithm : 算法
     * @param pubPath   : 公钥保存路径
     * @param priPath   : 私钥保存路径
     * @throws Exception
     */
    private static void generateKeyToFile(String algorithm, String pubPath, String priPath) throws Exception {
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);
        // 保存文件

        FileUtils.writeStringToFile(new File(pubPath), publicKeyString, StandardCharsets.UTF_8);
        FileUtils.writeStringToFile(new File(priPath), privateKeyString, StandardCharsets.UTF_8);
    }

    /**
     * 解密数据
     *
     * @param algorithm      : 算法
     * @param encrypted      : 密文
     * @param key            : 密钥
     * @return : 原文
     * @throws Exception
     */
    public static String decryptRSA(String algorithm,Key key,String encrypted) throws Exception{
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 私钥进行解密
        cipher.init(Cipher.DECRYPT_MODE,key);
        // 由于密文进行了Base64编码, 在这里需要进行解码
        byte[] decode = Base64.getDecoder().decode(encrypted);
        // 对密文进行解密，不需要使用base64，因为原文不会乱码
        byte[] bytes1 = cipher.doFinal(decode);
        System.out.println(new String(bytes1));
        return new String(bytes1);

    }
    /**
     * 使用密钥加密数据
     *
     * @param algorithm      : 算法
     * @param input          : 原文
     * @param key            : 密钥
     * @return : 密文
     * @throws Exception
     */
    public static String encryptRSA(String algorithm, Key key, String input) throws Exception{
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE, key);
        // 私钥加密
        byte[] bytes = cipher.doFinal(input.getBytes());
        // 对密文进行Base64编码
        System.out.println(Base64.getEncoder().encodeToString(bytes));
        return Base64.getEncoder().encodeToString(bytes);
    }
}
</code></pre>
<p>运行在项目目录下生成私钥</p>
<p>运行在项目目录下生成公钥</p>
<h3 id="读取私钥"><a class="header" href="#读取私钥">读取私钥</a></h3>
<pre><code class="language-java">package com.TianHan;

import java.io.File;
import java.nio.charset.Charset;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import org.apache.commons.io.FileUtils;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String path = "./code/src/main/resources/";

        // 加密算法
        String algorithm = "RSA";
        // 从文件读取私钥 ，这个是自定义的方法
        PrivateKey privateKey = getPrivateKey(path + "a.pri", algorithm);
        System.out.println("privateKey: " + privateKey);
    }

    public static PrivateKey getPrivateKey(String priPath,String algorithm) throws Exception{
        // 将文件内容转为字符串
        String privateKeyString = FileUtils.readFileToString(new File(priPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyString));
        // 生成私钥
        return keyFactory.generatePrivate(spec);
    }
}
</code></pre>
<h3 id="读取公钥"><a class="header" href="#读取公钥">读取公钥</a></h3>
<pre><code class="language-java">package com.TianHan;

import java.io.File;
import java.nio.charset.Charset;
import java.security.*;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import org.apache.commons.io.FileUtils;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String path = "./code/src/main/resources/";

        // 加密算法
        String algorithm = "RSA";
        PublicKey publicKey = getPublicKey(path + "a.pub", algorithm);
        System.out.println(publicKey);
    }

    public static PublicKey getPublicKey(String publicPath, String algorithm) throws Exception{
        // 将文件内容转为字符串
        String publicKeyString = FileUtils.readFileToString(new File(publicPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        X509EncodedKeySpec spec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyString));
        // 生成公钥
        return keyFactory.generatePublic(spec);
    }
}
</code></pre>
<h3 id="rsa加解密完整代码"><a class="header" href="#rsa加解密完整代码">RSA加解密完整代码</a></h3>
<pre><code class="language-java">package com.TianHan;

import javax.crypto.Cipher;
import java.io.File;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import org.apache.commons.io.FileUtils;

public class RSADemo {
    public static void main(String[] args) throws Exception {

        String plainText = "硅谷没有包子，就像中南海没有小李子一样。没有鸡翅，你吃的什么？";

        String path = "./code/src/main/resources/";
        // 加密算法
        String algorithm = "RSA";
        // 从文件读取私钥 ，这个是自定义的方法
        PrivateKey privateKey = getPrivateKey(path + "a.pri", algorithm);
        PublicKey publicKey = getPublicKey(path + "a.pub", algorithm);

        String encryptStr = encryptRSA(algorithm, privateKey, plainText);
        String decryptStr = decryptRSA(algorithm, publicKey, encryptStr);
        System.out.println(decryptStr);
    }

    public static PublicKey getPublicKey(String publicPath, String algorithm) throws Exception{
        // 将文件内容转为字符串
        String publicKeyString = FileUtils.readFileToString(new File(publicPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        X509EncodedKeySpec spec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyString));
        // 生成公钥
        return keyFactory.generatePublic(spec);
    }

    public static PrivateKey getPrivateKey(String priPath,String algorithm) throws Exception{
        // 将文件内容转为字符串
        String privateKeyString = FileUtils.readFileToString(new File(priPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyString));
        // 生成私钥
        return keyFactory.generatePrivate(spec);
    }

    /**
     * 生成密钥对并保存在本地文件中
     *
     * @param algorithm : 算法
     * @param pubPath   : 公钥保存路径
     * @param priPath   : 私钥保存路径
     * @throws Exception
     */
    private static void generateKeyToFile(String algorithm, String pubPath, String priPath) throws Exception {
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);
        // 保存文件

        FileUtils.writeStringToFile(new File(pubPath), publicKeyString, StandardCharsets.UTF_8);
        FileUtils.writeStringToFile(new File(priPath), privateKeyString, StandardCharsets.UTF_8);
    }

    /**
     * 解密数据
     *
     * @param algorithm      : 算法
     * @param encrypted      : 密文
     * @param key            : 密钥
     * @return : 原文
     * @throws Exception
     */
    public static String decryptRSA(String algorithm,Key key,String encrypted) throws Exception{
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 私钥进行解密
        cipher.init(Cipher.DECRYPT_MODE,key);
        // 由于密文进行了Base64编码, 在这里需要进行解码
        byte[] decode = Base64.getDecoder().decode(encrypted);
        // 对密文进行解密，不需要使用base64，因为原文不会乱码
        byte[] bytes1 = cipher.doFinal(decode);
        //System.out.println(new String(bytes1));
        return new String(bytes1);

    }
    /**
     * 使用密钥加密数据
     *
     * @param algorithm      : 算法
     * @param input          : 原文
     * @param key            : 密钥
     * @return : 密文
     * @throws Exception
     */
    public static String encryptRSA(String algorithm, Key key, String input) throws Exception{
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE, key);
        // 私钥加密
        byte[] bytes = cipher.doFinal(input.getBytes());
        // 对密文进行Base64编码
        //System.out.println(Base64.getEncoder().encodeToString(bytes));
        return Base64.getEncoder().encodeToString(bytes);
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="数字签名和数字证书"><a class="header" href="#数字签名和数字证书">数字签名和数字证书</a></h1>
<ul>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%85%AC%E9%92%A5%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">数字签名（公钥数字签名）</a>
<ul>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E8%B5%B7%E6%BA%90">起源</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E5%8F%91%E5%B1%95">发展</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E5%8E%9F%E7%90%86">原理</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">数字证书</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E7%BD%91%E9%A1%B5%E5%8A%A0%E5%AF%86">网页加密</a>
<ul>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7">网络监控</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4">隐私保护</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#python%E6%A8%A1%E6%8B%9F%E7%BD%91%E9%A1%B5%E5%8A%A0%E5%AF%86">Python模拟网页加密</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#ca%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83">CA认证中心</a>
<ul>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E8%B5%B7%E6%BA%90-1">起源</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E5%8F%91%E5%B1%95-1">发展</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E5%8E%9F%E7%90%86-1">原理</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E5%85%B8%E5%9E%8B%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83">典型认证中心</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%AE%9E%E6%88%98">数字签名实战</a>
<ul>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#python">Python</a></li>
<li><a href="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html#java">Java</a></li>
</ul>
</li>
</ul>
<h2 id="数字签名公钥数字签名"><a class="header" href="#数字签名公钥数字签名">数字签名（公钥数字签名）</a></h2>
<h3 id="起源"><a class="header" href="#起源">起源</a></h3>
<p>数字签名是一种用于确保数字信息的完整性和真实性的加密技术。它起源于1970年代的密码学领域，由Whitfield Diffie 和Martin Hellman首次提出了公钥密码体制。数字签名的原理是使用非对称加密算法生成一对密钥，分别是私钥和公钥。私钥由信息的发送者保管，公钥可以被任何人获取。</p>
<p>数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。</p>
<p>数字签名是非对称密钥加密技术与数字摘要技术的应用。</p>
<h3 id="发展"><a class="header" href="#发展">发展</a></h3>
<p>数字签名在发展过程中，逐渐被广泛应用在各种领域，包括电子支付、电子合同等。同时，为了满足不同应用场景的需求，不断有新的数字签名算法被提出，比如RSA、DSA等。随着互联网和移动通信技术的飞速发展，数字签名在保障信息安全和确保通信可靠性方面发挥着越来越重要的作用。</p>
<h3 id="原理-4"><a class="header" href="#原理-4">原理</a></h3>
<p>数字签名的生成过程一般分为两步：首先，信息的发送者使用私钥对信息进行加密，生成一个数字签名；然后，接收者使用发送者的公钥对数字签名进行解密，以验证信息的完整性和真实性。如果数字签名是有效的，接收者就可以确认信息确实是由发送者发送的，并且在传输过程中没有被篡改。</p>
<p>为了理解得清楚，我们通过案例一步一步来讲解。话说张三有俩好哥们A、B。由于工作原因，张三和AB写邮件的时候为了安全都需要加密。于是张三想到了数字签名：</p>
<p>整个思路是这个样子的：</p>
<p>第一步：加密采用非对称加密，张三有三把钥匙，两把公钥，送给朋友。一把私钥留给自己。</p>
<p>第二步：A或者B写邮件给张三：A先用公钥对邮件加密，然后张三收到邮件之后使用私钥解密。</p>
<p>第三步：张三写邮件给A或者B：</p>
<p>（1）张三写完邮件，先用hash函数生成邮件的摘要，附着在文章上面，这就完成了数字签名，然后张三再使用私钥加密。就可以把邮件发出去了。</p>
<p>（2）A或者是B收到邮件之后，先把数字签名取下来，然后使用自己的公钥解密即可。这时候取下来的数字签名中的摘要若和张三的一致，那就认为是张三发来的，再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<p>上面的流程我们使用一张图来演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img/20240919164855.png" alt="" /></p>
<p>服务器把内容（证书明文）经过hash算法得到证书的摘要，再经过私钥加密得到证书的数字签名，然后发送证书和数字签名给浏览器。</p>
<p>浏览器得到了证书和数字签名，先拿证书里的公钥对对数字签名解密得到摘要。再拿证书里的hash算法对证书进行hash得到摘要。对比连个摘要是否相同。如果相同，则代表证书没有被修改过，也就证明了是该服务器发过来的。</p>
<p>但是如果别人伪造了一个证书呢？比如证书里写的颁发给了baidu，而且公钥是第三者的，你发送的内容就被别人拦截下来用第三者的私钥解密，偷看后为了不被发现再用第三者的私钥加密发送给baidu。</p>
<p>为了验证证书没被篡改过，我们可以取认证中心鉴定。</p>
<h2 id="数字证书"><a class="header" href="#数字证书">数字证书</a></h2>
<p>数字证书是一种用于在网络通信中进行身份验证和加密数据传输的电子证书。它是CA数字认证中心（Certificate Authority）签发的，用于证明某个实体（个人、组织、服务器等）的身份和公钥的有效性。数字证书通常包含以下信息：</p>
<ol>
<li>
<p><strong>主题信息</strong>：证书持有者的信息，如姓名、电子邮件地址、组织名称等。</p>
</li>
<li>
<p><strong>公钥</strong>：用于加密和解密数据的公钥，公钥是证书持有者的一部分密钥对，另一部分是私钥，只有持有者才知道。</p>
</li>
<li>
<p><strong>证书序列号</strong>：标识证书的唯一序列号，用于区分不同的证书。</p>
</li>
<li>
<p><strong>证书有效期</strong>：证书的生效日期和过期日期，表示证书的有效期限。</p>
</li>
<li>
<p><strong>数字签名</strong>：CA数字认证中心对证书内容的签名，用于验证证书的真实性和完整性。</p>
</li>
</ol>
<p>数字证书的基本原理是通过CA数字认证中心信任链的支持，使用非对称加密算法来确保数字证书的可信性和安全性。一般来说，数字证书的签发流程包括以下步骤：</p>
<ol>
<li>
<p><strong>申请证书</strong>：证书持有者向CA数字认证中心提交证书申请，包括相关个人或组织的身份认证信息。</p>
</li>
<li>
<p><strong>验证身份</strong>：CA数字认证中心会对证书持有者提交的身份信息进行验证，确保其真实性，并签发数字证书。</p>
</li>
<li>
<p><strong>颁发证书</strong>：CA数字认证中心在验证通过后，会用自己的私钥对数字证书进行签名，并将数字证书发送给证书持有者。</p>
</li>
<li>
<p><strong>使用数字证书</strong>：证书持有者可以将数字证书应用于加密通信、签名验证、身份验证等场景，确保通信的安全性和可信性。</p>
</li>
</ol>
<p>在网页加密中，数字证书扮演着重要角色，用户在访问一个通过HTTPS协议保护的网站时，会验证网站的数字证书，以确认网站的身份和数据传输的安全性。数字证书是构建公钥基础设施（PKI）的核心组成部分，为网络通信提供了必要的安全保障。</p>
<h2 id="网页加密"><a class="header" href="#网页加密">网页加密</a></h2>
<p>网页加密的原理主要是通过使用HTTPS协议来保护网页的传输过程中的数据安全。HTTPS是HTTP与SSL/TLS协议的组合，可以确保网页在传输过程中的机密性、完整性和身份验证。</p>
<p>下面是网页加密的原理介绍：</p>
<ol>
<li>
<p><strong>建立安全连接</strong>：在使用HTTPS的网页上，用户打开网页时，浏览器会向网站请求建立安全连接。网站会发送自己的SSL证书给浏览器，证书包含了网站的公钥等信息。</p>
</li>
<li>
<p><strong>验证证书</strong>：浏览器会验证网站的SSL证书，确保证书的有效性和真实性。浏览器会检查证书的签发机构和有效期等信息，以确定当前网站的身份是否可信。</p>
</li>
<li>
<p><strong>生成会话密钥</strong>：一旦证书验证成功，浏览器会生成一个随机的会话密钥（对称密钥），用于加密网页内容的传输。</p>
</li>
<li>
<p><strong>加密数据传输</strong>：浏览器使用网站的公钥对会话密钥进行加密，并发送给网站。网站利用私钥解密得到会话密钥，之后浏览器和网站之间的通信会使用这个会话密钥对数据进行加密和解密。</p>
</li>
<li>
<p><strong>传输数据</strong>：一旦安全连接建立，网页上的数据（包括登录信息、个人数据等）在传输过程中都会被加密，保护数据的机密性。</p>
</li>
</ol>
<p>通过使用HTTPS协议，网页加密可以有效防止数据在传输过程中被窃取、篡改和窥探，提高了网页的安全性和用户的隐私保护。现在越来越多的网站都在推行使用HTTPS协议，以提供更安全可靠的访问环境。</p>
<h3 id="网络监控"><a class="header" href="#网络监控">网络监控</a></h3>
<p>虽然HTTPS协议可以加密网页传输过程中的数据，以保护数据的机密性，但外部机构如ISP、学校或公司仍然有能力检测到用户通过浏览器发生的数据。这是因为虽然HTTPS确保了数据传输过程中的加密和安全性，但并不阻止外部机构对一些元数据进行监视和检测。以下是一些原因：</p>
<ol>
<li>
<p><strong>域名解析</strong>：当用户在浏览器中输入一个网址时，浏览器首先会向DNS服务器发送一个域名解析请求，以获取网站的IP地址。这个请求是明文传输的，即使后续访问是通过HTTPS加密的，ISP仍然可以通过监视DNS请求来知道用户正在访问哪些网站。</p>
</li>
<li>
<p><strong>SNI扩展</strong>：在建立HTTPS连接时，客户端向服务器发送Server Name Indication (SNI)扩展，用于指定要访问的域名。这个SNI扩展是明文传输的，可以让网络中的设备（如防火墙、代理服务器）识别出用户正在访问哪个网站。</p>
</li>
<li>
<p><strong>SSL握手过程</strong>：在SSL/TLS握手过程中，通信双方会交换加密算法和密钥信息，这些信息中也包括明文的服务器证书。虽然握手过程中的关键数据是加密的，但一些元数据仍然是明文可见的，外部机构可以据此获取有关通信的信息。</p>
</li>
<li>
<p><strong>终端设备</strong>：外部机构也可以通过检测终端设备上的浏览历史、缓存数据等信息来掌握用户的网络活动。此外，浏览器的插件或工具也可能会泄露一些用户的浏览数据。</p>
</li>
</ol>
<p>总的来说，虽然HTTPS可以保护数据的机密性和安全性，但并不能完全阻止外部机构对用户网络活动的监视和检测。在一定程度上，外部机构仍然能够通过其他方式获取用户的网络活动信息。因此，用户在网络使用中，仍需保持警惕，注意个人隐私保护。</p>
<p>外部机构可以通过多种方式检测终端设备上的浏览历史、缓存数据等信息来了解用户的网络活动。以下是一些常见的方式：</p>
<ol>
<li>
<p><strong>浏览器历史记录</strong>：浏览器会保存用户的浏览历史记录，包括访问过的网页和搜索记录。外部机构可以通过访问用户的设备或网络流量分析来获取这些信息。</p>
</li>
<li>
<p><strong>Cookie和网站数据</strong>：网站可以在用户的设备上设置Cookie，用于跟踪用户的活动和偏好。外部机构可以访问用户设备上的Cookie数据来获取用户的活动信息。</p>
</li>
<li>
<p><strong>浏览器插件和扩展</strong>：一些恶意的浏览器插件和工具可能会窃取用户的浏览历史记录、密码等敏感信息，从而泄露用户的隐私。</p>
</li>
<li>
<p><strong>地址栏和搜索历史</strong>：外部机构可以通过访问用户设备上的地址栏和搜索历史记录来了解用户的搜索偏好和访问习惯。</p>
</li>
</ol>
<h3 id="隐私保护"><a class="header" href="#隐私保护">隐私保护</a></h3>
<p>为了防备外部机构通过检测终端设备上的浏览历史、缓存数据等信息来掌握用户的网络活动，用户可以采取一些措施：</p>
<ol>
<li>
<p><strong>定期清除浏览历史和缓存</strong>：定期清除浏览器的历史记录、缓存数据和Cookie，可以减少外部机构获取用户信息的可能性。</p>
</li>
<li>
<p><strong>使用隐身模式浏览</strong>：隐身模式浏览可以防止浏览记录、Cookie等数据被保存在设备上，提高个人隐私保护。</p>
</li>
<li>
<p><strong>谨慎安装浏览器插件</strong>：只安装信任的浏览器插件和扩展，避免安装未知来源或官方未审核的插件。</p>
</li>
<li>
<p><strong>使用VPN和加密工具</strong>：使用VPN服务和加密工具可以加密网络流量，提高网络通信的隐私性和安全性。</p>
</li>
<li>
<p><strong>定期更新和加强设备安全措施</strong>：更新操作系统和软件、安装杀毒软件和防火墙等安全措施，保护设备免受恶意软件和攻击。</p>
</li>
</ol>
<p>除被访问网站和浏览器之外的机构或组织通常不能直接获取用户的浏览器Cookie等信息，因为Cookie数据存储在用户设备上的浏览器中，并受同源策略限制（只有在同一域名下的网站才能访问和修改Cookie）。但有一些情况下，外部机构或组织可能会通过一些方式间接获取用户的浏览器Cookie等信息，例如：</p>
<ol>
<li>
<p><strong>网络嗅探</strong>：外部机构可以通过网络嗅探技术拦截用户的网络流量，尤其是未加密的HTTP流量。在HTTP请求和响应中，可能会携带用户的Cookie数据，外部机构可以从中获取这些数据。</p>
</li>
<li>
<p><strong>中间人攻击</strong>：外部机构可能通过在用户和目标服务器之间插入中间人进行攻击，欺骗用户设备和服务器之间的通信。在这种情况下，中间人可以获取用户的Cookie信息。</p>
</li>
<li>
<p><strong>恶意软件</strong>：一些恶意软件和浏览器插件可能会窃取用户设备上存储的Cookie等敏感信息，并将其传送给外部机构。这些恶意软件可能会通过社会工程学手段或漏洞利用等方式感染用户的设备。</p>
</li>
</ol>
<p>防止外部机构通过这些方式获取用户浏览器Cookie等信息可以采取以下措施：</p>
<ol>
<li>
<p>使用HTTPS连接：通过使用HTTPS连接访问网站可以加密数据传输，防止中间人窃听，提高数据安全性。</p>
</li>
<li>
<p>避免使用不安全的公共Wi-Fi：尽量避免在不安全的公共Wi-Fi网络上进行敏感操作，以免遭遇网络嗅探等攻击。</p>
</li>
<li>
<p>定期检查设备安全：定期检查设备上的恶意软件，并使用杀毒软件和防火墙等工具保护设备安全。</p>
</li>
<li>
<p>谨慎安装插件：只安装官方可信的浏览器插件和扩展，以避免安全风险。</p>
</li>
</ol>
<h3 id="python模拟网页加密"><a class="header" href="#python模拟网页加密">Python模拟网页加密</a></h3>
<p>是的，可以使用Python模拟网页加密的过程。虽然在实际生产环境中，网页加密是通过浏览器和服务器之间的SSL/TLS协议完成的，但是我们可以使用Python中的加密库和模块来模拟这一过程。</p>
<p>以下是一个简单的Python代码示例，演示了如何使用PyCryptodome库来模拟网页加密的过程：</p>
<pre><code class="language-python">from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

# 模拟网站端
private_key = RSA.generate(2048)
public_key = private_key.publickey()

# 模拟浏览器端
message = b"Hello, world!"

# 模拟浏览器端生成会话密钥
session_key = b"ThisIsASessionKey"

# 浏览器端使用网站的公钥对会话密钥进行加密
cipher = PKCS1_OAEP.new(public_key)
encrypted_session_key = cipher.encrypt(session_key)

# 网站服务端使用私钥解密得到会话密钥
decrypt_cipher = PKCS1_OAEP.new(private_key)
decrypted_session_key = decrypt_cipher.decrypt(encrypted_session_key)

# 利用会话密钥加密数据
data_cipher = PKCS1_OAEP.new(session_key)
encrypted_message = data_cipher.encrypt(message)

# 网站服务端解密数据
decrypted_message = data_cipher.decrypt(encrypted_message)

print("加密后的消息：", encrypted_message)
print("解密后的消息：", decrypted_message)
</code></pre>
<p>在上面的代码中，我们模拟了网站端生成RSA密钥对，浏览器端生成会话密钥并使用网站的公钥进行加密，然后网站端使用私钥解密得到会话密钥，并利用会话密钥对消息进行加密和解密的过程。虽然这只是简单的模拟，但可以帮助理解网页加密的基本原理。在实际应用中还需要结合真实的加密库和证书来保护网页传输的安全。</p>
<h2 id="ca认证中心"><a class="header" href="#ca认证中心">CA认证中心</a></h2>
<h3 id="起源-1"><a class="header" href="#起源-1">起源</a></h3>
<p>CA（Certificate Authority）数字认证中心，起源于公钥基础设施（PKI）的概念，最早可以追溯到1990年代。在网络通信中，PKI用于确保通信双方的身份验证、数据加密和签名的过程中。CA数字认证中心作为PKI的核心组成部分，负责颁发数字证书、管理密钥、验证身份等。</p>
<h3 id="发展-1"><a class="header" href="#发展-1">发展</a></h3>
<p>随着互联网的快速发展，CA数字认证中心变得越来越重要。各种网站、应用程序、电子商务平台等需要使用数字证书来保证用户数据的安全性和隐私保护。CA数字认证中心经历了不断的发展和完善，确保数字证书的可信性和安全性。</p>
<h3 id="原理-5"><a class="header" href="#原理-5">原理</a></h3>
<p>CA数字认证中心的原理是通过数字证书颁发机构来验证个体或组织的身份，并签发相应的数字证书。数字证书包括个体或组织的公钥和相关身份信息，由CA数字认证中心签名保证其可信性。在通信过程中，双方可以通过验证数字证书的有效性来确认对方的身份，并建立安全的通信通道。</p>
<h3 id="典型认证中心"><a class="header" href="#典型认证中心">典型认证中心</a></h3>
<ol>
<li>
<p>VeriSign：作为全球最大的CA数字认证中心之一，VeriSign在互联网安全领域有着较高的声誉。它颁发各种类型的数字证书，包括SSL证书、代码签名证书等。</p>
</li>
<li>
<p>Comodo：Comodo是一家知名的全球CA数字认证中心，拥有庞大的数字证书颁发网络。它提供多种类型的数字证书服务，广泛应用于企业网络、电子商务平台等领域。</p>
</li>
<li>
<p>Symantec：作为全球网络安全领域的领军企业之一，Symantec的CA数字认证中心致力于提供安全可靠的数字证书服务。它的数字证书被广泛应用于各种互联网和移动应用场景中。</p>
</li>
</ol>
<h2 id="数字签名实战"><a class="header" href="#数字签名实战">数字签名实战</a></h2>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>要使用Python实现数字签名，可以使用Python中的cryptography库。以下是一个示例代码，演示如何使用RSA算法对消息进行数字签名和验证：</p>
<pre><code class="language-python">from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes

# 生成RSA密钥对
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

public_key = private_key.public_key()

# 消息
message = b"天上地下，唯我独尊!"

# 对消息进行签名
signature = private_key.sign(
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
)

# 验证签名
try:
    public_key.verify(
        signature,
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    print("验证成功，消息未被篡改！")
except:
    print("验证失败，消息已被篡改！")
</code></pre>
<p>以上代码生成了一个RSA密钥对，使用私钥对消息进行签名，然后使用公钥验证签名的有效性。在验证过程中，如果签名有效，将输出“验证成功，消息未被篡改！”；如果签名无效，将输出“验证失败，消息已被篡改！”。</p>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<p>生成数字签名并校验</p>
<pre><code class="language-java">package com.TianHan;

import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.util.Base64;
import javax.crypto.Cipher;
import java.io.File;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import org.apache.commons.io.FileUtils;

public class DigitalSignatureDemo {
    public static void main(String[] args) throws Exception {

        String plainText = "时日曷丧，吾与汝皆亡。";
        String path = "./code/src/main/resources/";
        // 加密算法
        String algorithm = "RSA";
        // 从文件读取私钥 ，这个是自定义的方法
        PrivateKey privateKey = getPrivateKey(path + "a.pri", algorithm);
        PublicKey publicKey = getPublicKey(path + "a.pub", algorithm);

        // 数字签名
        String signatureAlgorithm = "SHA256withRSA";

        // Sign the plain text with the private key
        String hashedSignature = getHashedSignature(plainText, signatureAlgorithm, privateKey);
        //System.out.println("Hashed Signature: " + hashedSignature);
        boolean isVerified = verifySignature(plainText, signatureAlgorithm, publicKey, hashedSignature);
        System.out.println("Signature verified: " + isVerified);
    }


    /**
     * 生成签名
     *
     * @param plainText      : 原文
     * @param algorithm  : 算法
     * @param privateKey : 私钥
     * @return : 签名
     */

    private static String getHashedSignature(String plainText, String algorithm, PrivateKey privateKey) throws Exception {
        // TODO: Implement the digital signature algorithm
        // Use the private key to sign the plain text and return the hashed signature
        //获取签名对象
        Signature signature = Signature.getInstance(algorithm);
        //初始化签名对象
        signature.initSign(privateKey);
        //更新签名数据
        signature.update(plainText.getBytes());
        //生成签名
        byte[] signedBytes = signature.sign();

        //返回签名字符串
        return Base64.getEncoder().encodeToString(signedBytes);
    }

    /**
     * 校验签名
     *
     * @param plainText      : 原文
     * @param algorithm      : 算法
     * @param publicKey      : 公钥
     * @param hashedSignature : 签名
     * @return : 数据是否被篡改
     */
    private static boolean verifySignature(String plainText, String algorithm, PublicKey publicKey, String hashedSignature)throws Exception {
        // 获取签名对象
        Signature signature = Signature.getInstance(algorithm);
        // 初始化签名
        signature.initVerify(publicKey);
        // 传入原文
        signature.update(plainText.getBytes());
        // 校验数据，验证自己活得的签名和传入的签名是否匹配
        return signature.verify(Base64.getDecoder().decode(hashedSignature));

    }


    public static PublicKey getPublicKey(String publicPath, String algorithm) throws Exception {
        // 将文件内容转为字符串
        String publicKeyString = FileUtils.readFileToString(new File(publicPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        X509EncodedKeySpec spec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyString));
        // 生成公钥
        return keyFactory.generatePublic(spec);
    }

    public static PrivateKey getPrivateKey(String priPath, String algorithm) throws Exception {
        // 将文件内容转为字符串
        String privateKeyString = FileUtils.readFileToString(new File(priPath), Charset.defaultCharset());
        // 获取密钥工厂
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        // 构建密钥规范 进行Base64解码
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyString));
        // 生成私钥
        return keyFactory.generatePrivate(spec);
    }

    /**
     * 生成密钥对并保存在本地文件中
     *
     * @param algorithm : 算法
     * @param pubPath   : 公钥保存路径
     * @param priPath   : 私钥保存路径
     * @throws Exception
     */
    private static void generateKeyToFile(String algorithm, String pubPath, String priPath) throws Exception {
        //  创建密钥对生成器对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        // 生成密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        // 生成私钥
        PrivateKey privateKey = keyPair.getPrivate();
        // 生成公钥
        PublicKey publicKey = keyPair.getPublic();
        // 获取私钥字节数组
        byte[] privateKeyEncoded = privateKey.getEncoded();
        // 获取公钥字节数组
        byte[] publicKeyEncoded = publicKey.getEncoded();
        // 对公私钥进行base64编码
        String privateKeyString = Base64.getEncoder().encodeToString(privateKeyEncoded);
        String publicKeyString = Base64.getEncoder().encodeToString(publicKeyEncoded);
        // 保存文件

        FileUtils.writeStringToFile(new File(pubPath), publicKeyString, StandardCharsets.UTF_8);
        FileUtils.writeStringToFile(new File(priPath), privateKeyString, StandardCharsets.UTF_8);
    }

    /**
     * 解密数据
     *
     * @param algorithm : 算法
     * @param encrypted : 密文
     * @param key       : 密钥
     * @return : 原文
     * @throws Exception
     */
    public static String decryptRSA(String algorithm, Key key, String encrypted) throws Exception {
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 私钥进行解密
        cipher.init(Cipher.DECRYPT_MODE, key);
        // 由于密文进行了Base64编码, 在这里需要进行解码
        byte[] decode = Base64.getDecoder().decode(encrypted);
        // 对密文进行解密，不需要使用base64，因为原文不会乱码
        byte[] bytes1 = cipher.doFinal(decode);
        //System.out.println(new String(bytes1));
        return new String(bytes1);

    }

    /**
     * 使用密钥加密数据
     *
     * @param algorithm : 算法
     * @param input     : 原文
     * @param key       : 密钥
     * @return : 密文
     * @throws Exception
     */
    public static String encryptRSA(String algorithm, Key key, String input) throws Exception {
        // 创建加密对象
        // 参数表示加密算法
        Cipher cipher = Cipher.getInstance(algorithm);
        // 初始化加密
        // 第一个参数:加密的模式
        // 第二个参数：使用私钥进行加密
        cipher.init(Cipher.ENCRYPT_MODE, key);
        // 私钥加密
        byte[] bytes = cipher.doFinal(input.getBytes());
        // 对密文进行Base64编码
        //System.out.println(Base64.getEncoder().encodeToString(bytes));
        return Base64.getEncoder().encodeToString(bytes);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="隐写术"><a class="header" href="#隐写术">隐写术</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
